import{s as n,o as r,e as a,a as s,t,c as e,b as $,m as o,f as m,d as l,g as f,h as c,i as g,j as u,p as i}from"../chunks/scheduler.DX2ogySE.js";import{S as p,i as h,b as d,c as w,a as v,m as E,t as b,d as B,e as R}from"../chunks/index.C1TJfhvQ.js";import{C as x}from"../chunks/CodeSpan.DXNaiYkO.js";import{C}from"../chunks/CodeExecuter.CaPqni69.js";function P(n){let p,h,P,k,H,L,j,D,I,S,V,G,N,T,q,y,z,A,F,J,K,M,O,Q,U,W,X,Y,Z,_,nn,rn,an,sn,tn,en,$n,on,mn,ln,fn,cn,gn,un,pn,hn,dn,wn,vn,En,bn,Bn,Rn,xn,Cn,Pn,kn,Hn,Ln,jn,Dn,In,Sn,Vn,Gn,Nn,Tn,qn,yn="データの型";function zn(r){n[4](r)}V=new x({props:{data:["Number","white"]}}),N=new x({props:{data:["String","white"]}}),J=new x({props:{data:['""',"lightblue"]}}),X=new x({props:{data:["num","white"]}}),Z=new x({props:{data:["str","white"]}});let An={allowedGlobals:n[2]};return void 0!==n[1]&&(An.codeExeProps=n[1]),tn=new C({props:An}),n[3](tn),r.push((()=>d(tn,"codeExeProps",zn))),gn=new x({props:{data:["+","white"]}}),dn=new x({props:{data:["num + num","white"]}}),vn=new x({props:{data:["str + str","white"]}}),Rn=new x({props:{data:["str + num","white"]}}),jn=new x({props:{data:["-","white"]}}),In=new x({props:{data:["str - num","white"]}}),{c(){p=a("div"),h=a("h2"),h.textContent=yn,P=s(),k=a("div"),H=a("hr"),L=s(),j=a("p"),D=t("変数には様々なデータを代入することができます。データの種類を「型」とよびます。\n      "),I=a("br"),S=t("\n      型には様々な種類があり、たとえば「数値型("),w(V.$$.fragment),G=t(")」や「文字列型("),w(N.$$.fragment),T=t(")」があります。"),q=s(),y=a("hr"),z=s(),A=a("p"),F=t("数字は、囲み文字"),w(J.$$.fragment),K=t("で囲むと文字列型になり、囲まないと数値型として扱われます。\n      "),M=a("br"),O=t("\n      数字以外の文字を含む場合は、囲むと文字列型になり、囲まないと変数として扱われます。"),Q=s(),U=a("p"),W=t("このプログラムを実行して、"),w(X.$$.fragment),Y=t(" と "),w(Z.$$.fragment),_=t(" がどのように扱われるか見てみましょう。"),nn=s(),rn=a("hr"),an=s(),sn=a("div"),w(tn.$$.fragment),$n=s(),on=a("div"),mn=a("hr"),ln=s(),fn=a("p"),cn=t("また、"),w(gn.$$.fragment),un=t(" のような操作を「演算子」とよびますが、データの型によって演算子の効果が変わることがあります。\n      "),pn=a("br"),hn=t("\n      例えば、数値型同士を "),w(dn.$$.fragment),wn=t(" すると足し算をしますが、文字列型同士を "),w(vn.$$.fragment),En=t(" すると文字列をつなぎます。\n      "),bn=a("br"),Bn=t("\n      そして、文字列型と数値型を "),w(Rn.$$.fragment),xn=t(" すると、数値型が文字列型に変換され、文字列としてつなぎます。"),Cn=s(),Pn=a("hr"),kn=s(),Hn=a("p"),Ln=t("では、演算子 "),w(jn.$$.fragment),Dn=t(" を使うとどうなるでしょう？\n      "),w(In.$$.fragment),Sn=t(" に書き換えて実行してみましょう。\n      "),Vn=a("br"),Gn=t("\n      結果は予想通りでしたか？それとも不思議な結果でしたか？"),Nn=s(),Tn=a("hr"),this.h()},l(n){p=e(n,"DIV",{class:!0});var r=$(p);h=e(r,"H2",{class:!0,"data-svelte-h":!0}),"svelte-7kuwmt"!==o(h)&&(h.textContent=yn),P=m(r),k=e(r,"DIV",{class:!0});var a=$(k);H=e(a,"HR",{class:!0}),L=m(a),j=e(a,"P",{});var s=$(j);D=l(s,"変数には様々なデータを代入することができます。データの種類を「型」とよびます。\n      "),I=e(s,"BR",{}),S=l(s,"\n      型には様々な種類があり、たとえば「数値型("),v(V.$$.fragment,s),G=l(s,")」や「文字列型("),v(N.$$.fragment,s),T=l(s,")」があります。"),s.forEach(f),q=m(a),y=e(a,"HR",{class:!0}),z=m(a),A=e(a,"P",{});var t=$(A);F=l(t,"数字は、囲み文字"),v(J.$$.fragment,t),K=l(t,"で囲むと文字列型になり、囲まないと数値型として扱われます。\n      "),M=e(t,"BR",{}),O=l(t,"\n      数字以外の文字を含む場合は、囲むと文字列型になり、囲まないと変数として扱われます。"),t.forEach(f),Q=m(a),U=e(a,"P",{});var c=$(U);W=l(c,"このプログラムを実行して、"),v(X.$$.fragment,c),Y=l(c," と "),v(Z.$$.fragment,c),_=l(c," がどのように扱われるか見てみましょう。"),c.forEach(f),nn=m(a),rn=e(a,"HR",{class:!0}),a.forEach(f),an=m(r),sn=e(r,"DIV",{class:!0});var g=$(sn);v(tn.$$.fragment,g),g.forEach(f),$n=m(r),on=e(r,"DIV",{class:!0});var u=$(on);mn=e(u,"HR",{class:!0}),ln=m(u),fn=e(u,"P",{});var i=$(fn);cn=l(i,"また、"),v(gn.$$.fragment,i),un=l(i," のような操作を「演算子」とよびますが、データの型によって演算子の効果が変わることがあります。\n      "),pn=e(i,"BR",{}),hn=l(i,"\n      例えば、数値型同士を "),v(dn.$$.fragment,i),wn=l(i," すると足し算をしますが、文字列型同士を "),v(vn.$$.fragment,i),En=l(i," すると文字列をつなぎます。\n      "),bn=e(i,"BR",{}),Bn=l(i,"\n      そして、文字列型と数値型を "),v(Rn.$$.fragment,i),xn=l(i," すると、数値型が文字列型に変換され、文字列としてつなぎます。"),i.forEach(f),Cn=m(u),Pn=e(u,"HR",{class:!0}),kn=m(u),Hn=e(u,"P",{});var d=$(Hn);Ln=l(d,"では、演算子 "),v(jn.$$.fragment,d),Dn=l(d," を使うとどうなるでしょう？\n      "),v(In.$$.fragment,d),Sn=l(d," に書き換えて実行してみましょう。\n      "),Vn=e(d,"BR",{}),Gn=l(d,"\n      結果は予想通りでしたか？それとも不思議な結果でしたか？"),d.forEach(f),Nn=m(u),Tn=e(u,"HR",{class:!0}),u.forEach(f),r.forEach(f),this.h()},h(){c(h,"class","cLessonTitle"),c(H,"class","cBorderLine"),c(y,"class","cBorderLine"),c(rn,"class","cBorderLine"),c(k,"class","w-full"),c(sn,"class","cResponsiveCodeExecuter"),c(mn,"class","cBorderLine"),c(Pn,"class","cBorderLine"),c(Tn,"class","cBorderLine"),c(on,"class","w-full"),c(p,"class","cBookContents")},m(n,r){g(n,p,r),u(p,h),u(p,P),u(p,k),u(k,H),u(k,L),u(k,j),u(j,D),u(j,I),u(j,S),E(V,j,null),u(j,G),E(N,j,null),u(j,T),u(k,q),u(k,y),u(k,z),u(k,A),u(A,F),E(J,A,null),u(A,K),u(A,M),u(A,O),u(k,Q),u(k,U),u(U,W),E(X,U,null),u(U,Y),E(Z,U,null),u(U,_),u(k,nn),u(k,rn),u(p,an),u(p,sn),E(tn,sn,null),u(p,$n),u(p,on),u(on,mn),u(on,ln),u(on,fn),u(fn,cn),E(gn,fn,null),u(fn,un),u(fn,pn),u(fn,hn),E(dn,fn,null),u(fn,wn),E(vn,fn,null),u(fn,En),u(fn,bn),u(fn,Bn),E(Rn,fn,null),u(fn,xn),u(on,Cn),u(on,Pn),u(on,kn),u(on,Hn),u(Hn,Ln),E(jn,Hn,null),u(Hn,Dn),E(In,Hn,null),u(Hn,Sn),u(Hn,Vn),u(Hn,Gn),u(on,Nn),u(on,Tn),qn=!0},p(n,[r]){const a={};!en&&2&r&&(en=!0,a.codeExeProps=n[1],i((()=>en=!1))),tn.$set(a)},i(n){qn||(b(V.$$.fragment,n),b(N.$$.fragment,n),b(J.$$.fragment,n),b(X.$$.fragment,n),b(Z.$$.fragment,n),b(tn.$$.fragment,n),b(gn.$$.fragment,n),b(dn.$$.fragment,n),b(vn.$$.fragment,n),b(Rn.$$.fragment,n),b(jn.$$.fragment,n),b(In.$$.fragment,n),qn=!0)},o(n){B(V.$$.fragment,n),B(N.$$.fragment,n),B(J.$$.fragment,n),B(X.$$.fragment,n),B(Z.$$.fragment,n),B(tn.$$.fragment,n),B(gn.$$.fragment,n),B(dn.$$.fragment,n),B(vn.$$.fragment,n),B(Rn.$$.fragment,n),B(jn.$$.fragment,n),B(In.$$.fragment,n),qn=!1},d(r){r&&f(p),R(V),R(N),R(J),R(X),R(Z),n[3](null),R(tn),R(gn),R(dn),R(vn),R(Rn),R(jn),R(In)}}}function k(n,a,s){let t,e={code:'const num = 10;\nlog("number: " + num);\nlog(\'"number": \' + "num");\nlog("number+: " + (num + num));\n\nconst str = "100";\nlog("string: " + str);\nlog(\'"string": \' + "str");\nlog("string+: " + (str + str));\n\nreturn str + num;',resultString:"",logs:[]};return[t,e,{},function(n){r[n?"unshift":"push"]((()=>{t=n,s(0,t)}))},function(n){e=n,s(1,e)}]}class H extends p{constructor(r){super(),h(this,r,k,P,n,{})}}export{H as component};
