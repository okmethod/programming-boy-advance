import{s as n,p as e,e as a,a as t,t as r,c as $,b as s,m,f as l,d as f,g as o,h as g,i as u,j as p,q as c}from"../chunks/scheduler.BrQl0MTG.js";import{S as d,i,f as h,b as w,d as b,m as v,t as x,a as B,e as R}from"../chunks/index.BNSTJDHr.js";import{C}from"../chunks/CodeSpan.BjLYVJnM.js";import{C as E}from"../chunks/CodeExecuter.Bro6qtFl.js";function P(n){let d,i,P,H,L,j,k,I,S,D,V,y,T,q,z,K,M,O,A,G,N,F,J,Q,U,W,X,Y,Z,_,nn,en,an,tn,rn,$n,sn,mn,ln,fn,on,gn,un,pn,cn,dn,hn,wn,bn,vn,xn,Bn,Rn,Cn,En,Pn,Hn,Ln,jn,kn,In,Sn,Dn,Vn,yn,Tn,qn,zn,Kn,Mn,On,An,Gn,Nn,Fn,Jn,Qn,Un,Wn,Xn,Yn,Zn,_n,ne,ee,ae,te,re,$e,se,me,le,fe,oe,ge,ue,pe,ce,de,ie,he,we,be,ve,xe,Be="変数と関数",Re="プログラムには、2つの重要なアイテムがあります。それは「変数」と「関数」です。",Ce="「変数」は、「データ」を保存するための箱のようなものです。 データを変数に保存することを、「代入する」とよびます。",Ee="「関数」は、「操作」を保存するための箱のようなものです。\n      関数を呼び出すことで、それらの操作をまとめて実行できます。\n      <br/>\n      関数に渡すデータを「引数」とよび、関数から返されるデータを「戻り値」とよびます。",Pe="logs";function He(e){n[4](e)}z=new C({props:{data:[["let ","red"],["num","white"]]}}),M=new C({props:{data:["let","red"]}}),A=new C({props:{data:["num","white"]}}),J=new C({props:{data:["num","white"]}}),X=new C({props:{data:[["num = ","white"],["10","blue"]]}}),Z=new C({props:{data:["num","white"]}}),nn=new C({props:{data:["10","blue"]}}),rn=new C({props:{data:["=","white"]}}),pn=new C({props:{data:[["function ","red"],["double","purple"],["()","white"]]}}),wn=new C({props:{data:["function","red"]}}),vn=new C({props:{data:["double","purple"]}}),Cn=new C({props:{data:["arg","white"]}}),Dn=new C({props:{data:["num","white"]}}),yn=new C({props:{data:["double","purple"]}});let Le={allowedGlobals:n[2]};return void 0!==n[1]&&(Le.codeExeProps=n[1]),Fn=new E({props:Le}),n[3](Fn),e.push((()=>h(Fn,"codeExeProps",He))),_n=new C({props:{data:["let","red"]}}),ee=new C({props:{data:["const","red"]}}),$e=new C({props:{data:["let","red"]}}),fe=new C({props:{data:["const","red"]}}),pe=new C({props:{data:[["let ","red"],["num","white"]]}}),he=new C({props:{data:[["const ","red"],["num","white"]]}}),{c(){d=a("div"),i=a("h2"),i.textContent=Be,P=t(),H=a("div"),L=a("hr"),j=t(),k=a("p"),k.textContent=Re,I=t(),S=a("hr"),D=t(),V=a("p"),V.textContent=Ce,y=t(),T=a("p"),q=r("このプログラムでは、"),w(z.$$.fragment),K=r(" で変数を定義しています。\n      "),w(M.$$.fragment),O=r(" は変数の種類で、\n      "),w(A.$$.fragment),G=r(" は変数の名前です。\n      "),N=a("br"),F=r("\n      変数名は何でもOKですが、わかりやすい名前をつけることが大切です。（ちなみに、"),w(J.$$.fragment),Q=r(' は\n      "number" の頭文字からとった名前です）\n      '),U=a("br"),W=r("\n      また、"),w(X.$$.fragment),Y=r(" という式は、変数\n      "),w(Z.$$.fragment),_=r("\n      に "),w(nn.$$.fragment),en=r(" という数値を代入しています。\n      "),an=a("br"),tn=r("\n      （注意：プログラムにおける "),w(rn.$$.fragment),$n=r(" は「等しい」という意味ではなく、「代入する」という意味です）"),sn=t(),mn=a("hr"),ln=t(),fn=a("p"),fn.innerHTML=Ee,on=t(),gn=a("p"),un=r("このプログラムでは、"),w(pn.$$.fragment),cn=r(" で関数を定義しています。\n      "),dn=a("br"),hn=t(),w(wn.$$.fragment),bn=r(" は関数を表しており、\n      "),w(vn.$$.fragment),xn=r(" は関数の名前です。\n      "),Bn=a("br"),Rn=r("\n      この関数は、引数"),w(Cn.$$.fragment),En=r(" を受け取り、その値を2倍にして返します。"),Pn=t(),Hn=a("hr"),Ln=t(),jn=a("p"),kn=r("では、このプログラムを実行してみましょう。 "),In=a("br"),Sn=r("\n      変数"),w(Dn.$$.fragment),Vn=r(" が、関数"),w(yn.$$.fragment),Tn=r(" によって変化していく様子がわかるでしょうか？\n      "),qn=a("br"),zn=r("\n      （ヒント："),Kn=a("span"),Kn.textContent=Pe,Mn=r(" で、実行中の値の変化を確認できます）"),On=t(),An=a("hr"),Gn=t(),Nn=a("div"),w(Fn.$$.fragment),Qn=t(),Un=a("div"),Wn=a("hr"),Xn=t(),Yn=a("p"),Zn=r("実は、変数は 2種類あります。それは "),w(_n.$$.fragment),ne=r(" と\n      "),w(ee.$$.fragment),ae=r(" です。\n      "),te=a("br"),re=t(),w($e.$$.fragment),se=r(" は何度でも代入でき、値を書き換えることができる変数です。\n      "),me=a("br"),le=r("\n      一方で、"),w(fe.$$.fragment),oe=r(" は一度しか代入できず、値を書き換えることができない変数です。\n      "),ge=a("br"),ue=r("\n      このプログラムでは "),w(pe.$$.fragment),ce=r(" で変数を定義していますが、\n      "),de=a("br"),ie=r("\n      もし、これを "),w(he.$$.fragment),we=r(" に変更してから実行したら、結果はどうなるでしょうか？"),be=t(),ve=a("hr"),this.h()},l(n){d=$(n,"DIV",{class:!0});var e=s(d);i=$(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-mn1myz"!==m(i)&&(i.textContent=Be),P=l(e),H=$(e,"DIV",{class:!0});var a=s(H);L=$(a,"HR",{class:!0}),j=l(a),k=$(a,"P",{"data-svelte-h":!0}),"svelte-1p11vxu"!==m(k)&&(k.textContent=Re),I=l(a),S=$(a,"HR",{class:!0}),D=l(a),V=$(a,"P",{"data-svelte-h":!0}),"svelte-yi6x0d"!==m(V)&&(V.textContent=Ce),y=l(a),T=$(a,"P",{});var t=s(T);q=f(t,"このプログラムでは、"),b(z.$$.fragment,t),K=f(t," で変数を定義しています。\n      "),b(M.$$.fragment,t),O=f(t," は変数の種類で、\n      "),b(A.$$.fragment,t),G=f(t," は変数の名前です。\n      "),N=$(t,"BR",{}),F=f(t,"\n      変数名は何でもOKですが、わかりやすい名前をつけることが大切です。（ちなみに、"),b(J.$$.fragment,t),Q=f(t,' は\n      "number" の頭文字からとった名前です）\n      '),U=$(t,"BR",{}),W=f(t,"\n      また、"),b(X.$$.fragment,t),Y=f(t," という式は、変数\n      "),b(Z.$$.fragment,t),_=f(t,"\n      に "),b(nn.$$.fragment,t),en=f(t," という数値を代入しています。\n      "),an=$(t,"BR",{}),tn=f(t,"\n      （注意：プログラムにおける "),b(rn.$$.fragment,t),$n=f(t," は「等しい」という意味ではなく、「代入する」という意味です）"),t.forEach(o),sn=l(a),mn=$(a,"HR",{class:!0}),ln=l(a),fn=$(a,"P",{"data-svelte-h":!0}),"svelte-gyipz4"!==m(fn)&&(fn.innerHTML=Ee),on=l(a),gn=$(a,"P",{});var r=s(gn);un=f(r,"このプログラムでは、"),b(pn.$$.fragment,r),cn=f(r," で関数を定義しています。\n      "),dn=$(r,"BR",{}),hn=l(r),b(wn.$$.fragment,r),bn=f(r," は関数を表しており、\n      "),b(vn.$$.fragment,r),xn=f(r," は関数の名前です。\n      "),Bn=$(r,"BR",{}),Rn=f(r,"\n      この関数は、引数"),b(Cn.$$.fragment,r),En=f(r," を受け取り、その値を2倍にして返します。"),r.forEach(o),Pn=l(a),Hn=$(a,"HR",{class:!0}),Ln=l(a),jn=$(a,"P",{});var g=s(jn);kn=f(g,"では、このプログラムを実行してみましょう。 "),In=$(g,"BR",{}),Sn=f(g,"\n      変数"),b(Dn.$$.fragment,g),Vn=f(g," が、関数"),b(yn.$$.fragment,g),Tn=f(g," によって変化していく様子がわかるでしょうか？\n      "),qn=$(g,"BR",{}),zn=f(g,"\n      （ヒント："),Kn=$(g,"SPAN",{class:!0,"data-svelte-h":!0}),"svelte-76rfbh"!==m(Kn)&&(Kn.textContent=Pe),Mn=f(g," で、実行中の値の変化を確認できます）"),g.forEach(o),On=l(a),An=$(a,"HR",{class:!0}),a.forEach(o),Gn=l(e),Nn=$(e,"DIV",{class:!0});var u=s(Nn);b(Fn.$$.fragment,u),u.forEach(o),Qn=l(e),Un=$(e,"DIV",{class:!0});var p=s(Un);Wn=$(p,"HR",{class:!0}),Xn=l(p),Yn=$(p,"P",{});var c=s(Yn);Zn=f(c,"実は、変数は 2種類あります。それは "),b(_n.$$.fragment,c),ne=f(c," と\n      "),b(ee.$$.fragment,c),ae=f(c," です。\n      "),te=$(c,"BR",{}),re=l(c),b($e.$$.fragment,c),se=f(c," は何度でも代入でき、値を書き換えることができる変数です。\n      "),me=$(c,"BR",{}),le=f(c,"\n      一方で、"),b(fe.$$.fragment,c),oe=f(c," は一度しか代入できず、値を書き換えることができない変数です。\n      "),ge=$(c,"BR",{}),ue=f(c,"\n      このプログラムでは "),b(pe.$$.fragment,c),ce=f(c," で変数を定義していますが、\n      "),de=$(c,"BR",{}),ie=f(c,"\n      もし、これを "),b(he.$$.fragment,c),we=f(c," に変更してから実行したら、結果はどうなるでしょうか？"),c.forEach(o),be=l(p),ve=$(p,"HR",{class:!0}),p.forEach(o),e.forEach(o),this.h()},h(){g(i,"class","cLessonTitle"),g(L,"class","cBorderLine"),g(S,"class","cBorderLine"),g(mn,"class","cBorderLine"),g(Hn,"class","cBorderLine"),g(Kn,"class","cIndexSpan"),g(An,"class","cBorderLine"),g(H,"class","w-full"),g(Nn,"class","cResponsiveCodeExecuter"),g(Wn,"class","cBorderLine"),g(ve,"class","cBorderLine"),g(Un,"class","w-full"),g(d,"class","cBookContents")},m(n,e){u(n,d,e),p(d,i),p(d,P),p(d,H),p(H,L),p(H,j),p(H,k),p(H,I),p(H,S),p(H,D),p(H,V),p(H,y),p(H,T),p(T,q),v(z,T,null),p(T,K),v(M,T,null),p(T,O),v(A,T,null),p(T,G),p(T,N),p(T,F),v(J,T,null),p(T,Q),p(T,U),p(T,W),v(X,T,null),p(T,Y),v(Z,T,null),p(T,_),v(nn,T,null),p(T,en),p(T,an),p(T,tn),v(rn,T,null),p(T,$n),p(H,sn),p(H,mn),p(H,ln),p(H,fn),p(H,on),p(H,gn),p(gn,un),v(pn,gn,null),p(gn,cn),p(gn,dn),p(gn,hn),v(wn,gn,null),p(gn,bn),v(vn,gn,null),p(gn,xn),p(gn,Bn),p(gn,Rn),v(Cn,gn,null),p(gn,En),p(H,Pn),p(H,Hn),p(H,Ln),p(H,jn),p(jn,kn),p(jn,In),p(jn,Sn),v(Dn,jn,null),p(jn,Vn),v(yn,jn,null),p(jn,Tn),p(jn,qn),p(jn,zn),p(jn,Kn),p(jn,Mn),p(H,On),p(H,An),p(d,Gn),p(d,Nn),v(Fn,Nn,null),p(d,Qn),p(d,Un),p(Un,Wn),p(Un,Xn),p(Un,Yn),p(Yn,Zn),v(_n,Yn,null),p(Yn,ne),v(ee,Yn,null),p(Yn,ae),p(Yn,te),p(Yn,re),v($e,Yn,null),p(Yn,se),p(Yn,me),p(Yn,le),v(fe,Yn,null),p(Yn,oe),p(Yn,ge),p(Yn,ue),v(pe,Yn,null),p(Yn,ce),p(Yn,de),p(Yn,ie),v(he,Yn,null),p(Yn,we),p(Un,be),p(Un,ve),xe=!0},p(n,[e]){const a={};!Jn&&2&e&&(Jn=!0,a.codeExeProps=n[1],c((()=>Jn=!1))),Fn.$set(a)},i(n){xe||(x(z.$$.fragment,n),x(M.$$.fragment,n),x(A.$$.fragment,n),x(J.$$.fragment,n),x(X.$$.fragment,n),x(Z.$$.fragment,n),x(nn.$$.fragment,n),x(rn.$$.fragment,n),x(pn.$$.fragment,n),x(wn.$$.fragment,n),x(vn.$$.fragment,n),x(Cn.$$.fragment,n),x(Dn.$$.fragment,n),x(yn.$$.fragment,n),x(Fn.$$.fragment,n),x(_n.$$.fragment,n),x(ee.$$.fragment,n),x($e.$$.fragment,n),x(fe.$$.fragment,n),x(pe.$$.fragment,n),x(he.$$.fragment,n),xe=!0)},o(n){B(z.$$.fragment,n),B(M.$$.fragment,n),B(A.$$.fragment,n),B(J.$$.fragment,n),B(X.$$.fragment,n),B(Z.$$.fragment,n),B(nn.$$.fragment,n),B(rn.$$.fragment,n),B(pn.$$.fragment,n),B(wn.$$.fragment,n),B(vn.$$.fragment,n),B(Cn.$$.fragment,n),B(Dn.$$.fragment,n),B(yn.$$.fragment,n),B(Fn.$$.fragment,n),B(_n.$$.fragment,n),B(ee.$$.fragment,n),B($e.$$.fragment,n),B(fe.$$.fragment,n),B(pe.$$.fragment,n),B(he.$$.fragment,n),xe=!1},d(e){e&&o(d),R(z),R(M),R(A),R(J),R(X),R(Z),R(nn),R(rn),R(pn),R(wn),R(vn),R(Cn),R(Dn),R(yn),n[3](null),R(Fn),R(_n),R(ee),R($e),R(fe),R(pe),R(he)}}}function H(n,a,t){let r,$={code:'function double(arg) {\n  return arg * 2;\n}\n\nlet num = 10;\nlog("num1: " + num);\nnum = double(num);\nlog("num2: " + num);\nnum = double(num);\nlog("num3: " + num);\n\nreturn num;',resultString:"",logs:[]};return[r,$,{},function(n){e[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){$=n,t(1,$)}]}class L extends d{constructor(e){super(),i(this,e,H,P,n,{})}}export{L as component};
