import{s as n,p as e,e as a,a as r,t,c as $,b as s,m as f,f as l,d as m,g,h as o,i as u,j as c,q as p}from"../chunks/scheduler.Cs3I9vKP.js";import{S as d,i,f as h,b as w,d as b,m as B,t as v,a as R,e as E}from"../chunks/index.bCNU049k.js";import{C as x}from"../chunks/CodeSpan.BW9k6w2T.js";import{C}from"../chunks/CodeExecuter.BsLfRXkg.js";function H(n){let d,i,H,L,P,j,k,D,I,S,V,q,G,O,T,y,z,A,F,J,K,M,N,Q,U,W,X,Y,Z,_,nn,en,an,rn,tn,$n,sn,fn,ln,mn,gn,on,un,cn,pn,dn,hn,wn,bn,Bn,vn,Rn,En,xn,Cn,Hn,Ln,Pn,jn,kn,Dn,In,Sn,Vn,qn,Gn,On,Tn,yn,zn,An,Fn,Jn,Kn,Mn,Nn,Qn,Un,Wn,Xn,Yn,Zn,_n="条件分岐";function ne(e){n[4](e)}I=new x({props:{data:["if","red"]}}),G=new x({props:{data:[["if","red"],[" ( ... )","white"]]}}),K=new x({props:{data:["num","white"]}}),U=new x({props:{data:["%","white"]}}),X=new x({props:{data:[["num % ","white"],["2","blue"]]}}),Z=new x({props:{data:["num","white"]}}),nn=new x({props:{data:["2","blue"]}}),tn=new x({props:{data:["0","blue"]}}),ln=new x({props:{data:["num","white"]}});let ee={allowedGlobals:n[2]};return void 0!==n[1]&&(ee.codeExeProps=n[1]),cn=new C({props:ee}),n[3](cn),e.push((()=>h(cn,"codeExeProps",ne))),vn=new x({props:{data:["===","white"]}}),Cn=new x({props:{data:["true","blue"]}}),Ln=new x({props:{data:["false","blue"]}}),jn=new x({props:{data:["Boolean","white"]}}),Sn=new x({props:{data:[["if","red"],[" ( ... )","white"]]}}),qn=new x({props:{data:["{ ... }","white"]}}),yn=new x({props:{data:[["else ","red"],["{ ... }","white"]]}}),Nn=new x({props:{data:[["const ","red"],["num = ","white"],['"str"',"lightblue"]]}}),{c(){d=a("div"),i=a("h2"),i.textContent=_n,H=r(),L=a("div"),P=a("hr"),j=r(),k=a("p"),D=t("次に紹介する強力なアイテムは「条件分岐("),w(I.$$.fragment),S=t("分岐)」です。\n      "),V=a("br"),q=t("\n      条件分岐は、"),w(G.$$.fragment),O=t(" の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),T=a("br"),y=r(),z=a("hr"),A=r(),F=a("p"),J=t("このプログラムでは、変数"),w(K.$$.fragment),M=t(" が偶数か奇数かを判定しています。\n      "),N=a("br"),Q=r(),w(U.$$.fragment),W=t(" は割り算の余りを求める演算子で、\n      "),w(X.$$.fragment),Y=t(" は\n      "),w(Z.$$.fragment),_=t(" を\n      "),w(nn.$$.fragment),en=t(" で割った余りを求めます。\n      "),an=a("br"),rn=t("\n      偶数の場合、割り切れるので余りは "),w(tn.$$.fragment),$n=t(" になります。\n      "),sn=a("br"),fn=t("\n      実行して確かめてみましょう。 また、\n      "),w(ln.$$.fragment),mn=t(" を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),gn=r(),on=a("hr"),un=r(),w(cn.$$.fragment),dn=r(),hn=a("div"),wn=a("hr"),bn=r(),Bn=a("p"),w(vn.$$.fragment),Rn=t(" は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),En=a("br"),xn=t("\n      真偽値とは、「真("),w(Cn.$$.fragment),Hn=t(")」または「偽("),w(Ln.$$.fragment),Pn=t(")」のどちらかを取る、「真偽型("),w(jn.$$.fragment),kn=t(")」の値です。\n      "),Dn=a("br"),In=r(),w(Sn.$$.fragment),Vn=t(" の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),w(qn.$$.fragment),Gn=t(" の中の処理が実行されます。\n      "),On=a("br"),Tn=r(),w(yn.$$.fragment),zn=t(" の中の処理は、条件式が偽となる場合に実行されます。"),An=r(),Fn=a("hr"),Jn=r(),Kn=a("p"),Mn=t("では、もし "),w(Nn.$$.fragment),Qn=t(" としたら結果はどうなるでしょう？\n      "),Un=a("br"),Wn=t("\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),Xn=r(),Yn=a("hr"),this.h()},l(n){d=$(n,"DIV",{class:!0});var e=s(d);i=$(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-1rh1fwt"!==f(i)&&(i.textContent=_n),H=l(e),L=$(e,"DIV",{class:!0});var a=s(L);P=$(a,"HR",{class:!0}),j=l(a),k=$(a,"P",{});var r=s(k);D=m(r,"次に紹介する強力なアイテムは「条件分岐("),b(I.$$.fragment,r),S=m(r,"分岐)」です。\n      "),V=$(r,"BR",{}),q=m(r,"\n      条件分岐は、"),b(G.$$.fragment,r),O=m(r," の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),T=$(r,"BR",{}),r.forEach(g),y=l(a),z=$(a,"HR",{class:!0}),A=l(a),F=$(a,"P",{});var t=s(F);J=m(t,"このプログラムでは、変数"),b(K.$$.fragment,t),M=m(t," が偶数か奇数かを判定しています。\n      "),N=$(t,"BR",{}),Q=l(t),b(U.$$.fragment,t),W=m(t," は割り算の余りを求める演算子で、\n      "),b(X.$$.fragment,t),Y=m(t," は\n      "),b(Z.$$.fragment,t),_=m(t," を\n      "),b(nn.$$.fragment,t),en=m(t," で割った余りを求めます。\n      "),an=$(t,"BR",{}),rn=m(t,"\n      偶数の場合、割り切れるので余りは "),b(tn.$$.fragment,t),$n=m(t," になります。\n      "),sn=$(t,"BR",{}),fn=m(t,"\n      実行して確かめてみましょう。 また、\n      "),b(ln.$$.fragment,t),mn=m(t," を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),t.forEach(g),gn=l(a),on=$(a,"HR",{class:!0}),a.forEach(g),un=l(e),b(cn.$$.fragment,e),dn=l(e),hn=$(e,"DIV",{class:!0});var o=s(hn);wn=$(o,"HR",{class:!0}),bn=l(o),Bn=$(o,"P",{});var u=s(Bn);b(vn.$$.fragment,u),Rn=m(u," は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),En=$(u,"BR",{}),xn=m(u,"\n      真偽値とは、「真("),b(Cn.$$.fragment,u),Hn=m(u,")」または「偽("),b(Ln.$$.fragment,u),Pn=m(u,")」のどちらかを取る、「真偽型("),b(jn.$$.fragment,u),kn=m(u,")」の値です。\n      "),Dn=$(u,"BR",{}),In=l(u),b(Sn.$$.fragment,u),Vn=m(u," の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),b(qn.$$.fragment,u),Gn=m(u," の中の処理が実行されます。\n      "),On=$(u,"BR",{}),Tn=l(u),b(yn.$$.fragment,u),zn=m(u," の中の処理は、条件式が偽となる場合に実行されます。"),u.forEach(g),An=l(o),Fn=$(o,"HR",{class:!0}),Jn=l(o),Kn=$(o,"P",{});var c=s(Kn);Mn=m(c,"では、もし "),b(Nn.$$.fragment,c),Qn=m(c," としたら結果はどうなるでしょう？\n      "),Un=$(c,"BR",{}),Wn=m(c,"\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),c.forEach(g),Xn=l(o),Yn=$(o,"HR",{class:!0}),o.forEach(g),e.forEach(g),this.h()},h(){o(i,"class","cLessonTitle"),o(P,"class","cBorderLine"),o(z,"class","cBorderLine"),o(on,"class","cBorderLine"),o(L,"class","w-full"),o(wn,"class","cBorderLine"),o(Fn,"class","cBorderLine"),o(Yn,"class","cBorderLine"),o(hn,"class","w-full"),o(d,"class","cBookContents")},m(n,e){u(n,d,e),c(d,i),c(d,H),c(d,L),c(L,P),c(L,j),c(L,k),c(k,D),B(I,k,null),c(k,S),c(k,V),c(k,q),B(G,k,null),c(k,O),c(k,T),c(L,y),c(L,z),c(L,A),c(L,F),c(F,J),B(K,F,null),c(F,M),c(F,N),c(F,Q),B(U,F,null),c(F,W),B(X,F,null),c(F,Y),B(Z,F,null),c(F,_),B(nn,F,null),c(F,en),c(F,an),c(F,rn),B(tn,F,null),c(F,$n),c(F,sn),c(F,fn),B(ln,F,null),c(F,mn),c(L,gn),c(L,on),c(d,un),B(cn,d,null),c(d,dn),c(d,hn),c(hn,wn),c(hn,bn),c(hn,Bn),B(vn,Bn,null),c(Bn,Rn),c(Bn,En),c(Bn,xn),B(Cn,Bn,null),c(Bn,Hn),B(Ln,Bn,null),c(Bn,Pn),B(jn,Bn,null),c(Bn,kn),c(Bn,Dn),c(Bn,In),B(Sn,Bn,null),c(Bn,Vn),B(qn,Bn,null),c(Bn,Gn),c(Bn,On),c(Bn,Tn),B(yn,Bn,null),c(Bn,zn),c(hn,An),c(hn,Fn),c(hn,Jn),c(hn,Kn),c(Kn,Mn),B(Nn,Kn,null),c(Kn,Qn),c(Kn,Un),c(Kn,Wn),c(hn,Xn),c(hn,Yn),Zn=!0},p(n,[e]){const a={};!pn&&2&e&&(pn=!0,a.codeExeProps=n[1],p((()=>pn=!1))),cn.$set(a)},i(n){Zn||(v(I.$$.fragment,n),v(G.$$.fragment,n),v(K.$$.fragment,n),v(U.$$.fragment,n),v(X.$$.fragment,n),v(Z.$$.fragment,n),v(nn.$$.fragment,n),v(tn.$$.fragment,n),v(ln.$$.fragment,n),v(cn.$$.fragment,n),v(vn.$$.fragment,n),v(Cn.$$.fragment,n),v(Ln.$$.fragment,n),v(jn.$$.fragment,n),v(Sn.$$.fragment,n),v(qn.$$.fragment,n),v(yn.$$.fragment,n),v(Nn.$$.fragment,n),Zn=!0)},o(n){R(I.$$.fragment,n),R(G.$$.fragment,n),R(K.$$.fragment,n),R(U.$$.fragment,n),R(X.$$.fragment,n),R(Z.$$.fragment,n),R(nn.$$.fragment,n),R(tn.$$.fragment,n),R(ln.$$.fragment,n),R(cn.$$.fragment,n),R(vn.$$.fragment,n),R(Cn.$$.fragment,n),R(Ln.$$.fragment,n),R(jn.$$.fragment,n),R(Sn.$$.fragment,n),R(qn.$$.fragment,n),R(yn.$$.fragment,n),R(Nn.$$.fragment,n),Zn=!1},d(e){e&&g(d),E(I),E(G),E(K),E(U),E(X),E(Z),E(nn),E(tn),E(ln),n[3](null),E(cn),E(vn),E(Cn),E(Ln),E(jn),E(Sn),E(qn),E(yn),E(Nn)}}}function L(n,a,r){let t,$={code:'const num = 10;\nlet result;\nif (num % 2 === 0) {\n  result = num + " is Even.";\n} else {\n  result = num + " is Odd.";\n}\nreturn result;',resultString:"",logs:[]};return[t,$,{},function(n){e[n?"unshift":"push"]((()=>{t=n,r(0,t)}))},function(n){$=n,r(1,$)}]}class P extends d{constructor(e){super(),i(this,e,L,H,n,{})}}export{P as component};
