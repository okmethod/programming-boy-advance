import{s as n,p as e,e as a,a as t,t as r,c as $,b as s,m,f as l,d as f,g as o,h as g,i as u,j as p,q as c}from"../chunks/scheduler.Cp4pqcvj.js";import{S as d,i,f as h,b as w,d as b,m as v,t as x,a as B,e as R}from"../chunks/index.BnBan4aP.js";import{C}from"../chunks/CodeSpan.BLKkMGKW.js";import{C as E}from"../chunks/CodeExecuter.DSXtMKtX.js";function P(n){let d,i,P,H,L,j,k,S,I,y,D,T,V,z,K,M,O,q,A,G,N,F,J,Q,U,W,X,Y,Z,_,nn,en,an,tn,rn,$n,sn,mn,ln,fn,on,gn,un,pn,cn,dn,hn,wn,bn,vn,xn,Bn,Rn,Cn,En,Pn,Hn,Ln,jn,kn,Sn,In,yn,Dn,Tn,Vn,zn,Kn,Mn,On,qn,An,Gn,Nn,Fn,Jn,Qn,Un,Wn,Xn,Yn,Zn,_n,ne,ee,ae,te,re,$e,se,me,le,fe,oe,ge,ue,pe,ce,de,ie,he,we,be,ve,xe="変数と関数",Be="プログラムには、2つの重要なアイテムがあります。それは「変数」と「関数」です。",Re="「変数」は、「データ」を保存するための箱のようなものです。 データを変数に保存することを、「代入する」とよびます。",Ce="「関数」は、「操作」を保存するための箱のようなものです。\n      関数を呼び出すことで、それらの操作をまとめて実行できます。\n      <br/>\n      関数に渡すデータを「引数」とよび、関数から返されるデータを「戻り値」とよびます。",Ee="logs";function Pe(e){n[3](e)}K=new C({props:{data:[["let ","red"],["num","white"]]}}),O=new C({props:{data:["let","red"]}}),A=new C({props:{data:["num","white"]}}),J=new C({props:{data:["num","white"]}}),X=new C({props:{data:[["num = ","white"],["10","blue"]]}}),Z=new C({props:{data:["num","white"]}}),nn=new C({props:{data:["10","blue"]}}),rn=new C({props:{data:["=","white"]}}),pn=new C({props:{data:[["function ","red"],["double","purple"],["()","white"]]}}),wn=new C({props:{data:["function","red"]}}),vn=new C({props:{data:["double","purple"]}}),Cn=new C({props:{data:["arg","white"]}}),yn=new C({props:{data:["num","white"]}}),Tn=new C({props:{data:["double","purple"]}});let He={};return void 0!==n[1]&&(He.codeExeProps=n[1]),Nn=new E({props:He}),n[2](Nn),e.push((()=>h(Nn,"codeExeProps",Pe))),Zn=new C({props:{data:["let","red"]}}),ne=new C({props:{data:["const","red"]}}),re=new C({props:{data:["let","red"]}}),le=new C({props:{data:["const","red"]}}),ue=new C({props:{data:[["let ","red"],["num","white"]]}}),ie=new C({props:{data:[["const ","red"],["num","white"]]}}),{c(){d=a("div"),i=a("h2"),i.textContent=xe,P=t(),H=a("div"),L=a("hr"),j=t(),k=a("p"),k.textContent=Be,S=t(),I=a("hr"),y=t(),D=a("p"),D.textContent=Re,T=t(),V=a("p"),z=r("このプログラムでは、"),w(K.$$.fragment),M=r(" で変数を定義しています。\n      "),w(O.$$.fragment),q=r(" は変数の種類で、\n      "),w(A.$$.fragment),G=r(" は変数の名前です。\n      "),N=a("br"),F=r("\n      変数名は何でもOKですが、わかりやすい名前をつけることが大切です。（ちなみに、"),w(J.$$.fragment),Q=r(' は\n      "number" の頭文字からとった名前です）\n      '),U=a("br"),W=r("\n      また、"),w(X.$$.fragment),Y=r(" という式は、変数\n      "),w(Z.$$.fragment),_=r("\n      に "),w(nn.$$.fragment),en=r(" という数値を代入しています。\n      "),an=a("br"),tn=r("\n      （注意：プログラムにおける "),w(rn.$$.fragment),$n=r(" は「等しい」という意味ではなく、「代入する」という意味です）"),sn=t(),mn=a("hr"),ln=t(),fn=a("p"),fn.innerHTML=Ce,on=t(),gn=a("p"),un=r("このプログラムでは、"),w(pn.$$.fragment),cn=r(" で関数を定義しています。\n      "),dn=a("br"),hn=t(),w(wn.$$.fragment),bn=r(" は関数を表しており、\n      "),w(vn.$$.fragment),xn=r(" は関数の名前です。\n      "),Bn=a("br"),Rn=r("\n      この関数は、引数"),w(Cn.$$.fragment),En=r(" を受け取り、その値を2倍にして返します。"),Pn=t(),Hn=a("hr"),Ln=t(),jn=a("p"),kn=r("では、このプログラムを実行してみましょう。 "),Sn=a("br"),In=r("\n      変数"),w(yn.$$.fragment),Dn=r(" が、関数"),w(Tn.$$.fragment),Vn=r(" によって変化していく様子がわかるでしょうか？\n      "),zn=a("br"),Kn=r("\n      （ヒント："),Mn=a("span"),Mn.textContent=Ee,On=r(" で、実行中の値の変化を確認できます）"),qn=t(),An=a("hr"),Gn=t(),w(Nn.$$.fragment),Jn=t(),Qn=a("div"),Un=a("hr"),Wn=t(),Xn=a("p"),Yn=r("実は、変数は 2種類あります。それは "),w(Zn.$$.fragment),_n=r(" と\n      "),w(ne.$$.fragment),ee=r(" です。\n      "),ae=a("br"),te=t(),w(re.$$.fragment),$e=r(" は何度でも代入でき、値を書き換えることができる変数です。\n      "),se=a("br"),me=r("\n      一方で、"),w(le.$$.fragment),fe=r(" は一度しか代入できず、値を書き換えることができない変数です。\n      "),oe=a("br"),ge=r("\n      このプログラムでは "),w(ue.$$.fragment),pe=r(" で変数を定義していますが、\n      "),ce=a("br"),de=r("\n      もし、これを "),w(ie.$$.fragment),he=r(" に変更してから実行したら、結果はどうなるでしょうか？"),we=t(),be=a("hr"),this.h()},l(n){d=$(n,"DIV",{class:!0});var e=s(d);i=$(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-mn1myz"!==m(i)&&(i.textContent=xe),P=l(e),H=$(e,"DIV",{class:!0});var a=s(H);L=$(a,"HR",{class:!0}),j=l(a),k=$(a,"P",{"data-svelte-h":!0}),"svelte-1p11vxu"!==m(k)&&(k.textContent=Be),S=l(a),I=$(a,"HR",{class:!0}),y=l(a),D=$(a,"P",{"data-svelte-h":!0}),"svelte-yi6x0d"!==m(D)&&(D.textContent=Re),T=l(a),V=$(a,"P",{});var t=s(V);z=f(t,"このプログラムでは、"),b(K.$$.fragment,t),M=f(t," で変数を定義しています。\n      "),b(O.$$.fragment,t),q=f(t," は変数の種類で、\n      "),b(A.$$.fragment,t),G=f(t," は変数の名前です。\n      "),N=$(t,"BR",{}),F=f(t,"\n      変数名は何でもOKですが、わかりやすい名前をつけることが大切です。（ちなみに、"),b(J.$$.fragment,t),Q=f(t,' は\n      "number" の頭文字からとった名前です）\n      '),U=$(t,"BR",{}),W=f(t,"\n      また、"),b(X.$$.fragment,t),Y=f(t," という式は、変数\n      "),b(Z.$$.fragment,t),_=f(t,"\n      に "),b(nn.$$.fragment,t),en=f(t," という数値を代入しています。\n      "),an=$(t,"BR",{}),tn=f(t,"\n      （注意：プログラムにおける "),b(rn.$$.fragment,t),$n=f(t," は「等しい」という意味ではなく、「代入する」という意味です）"),t.forEach(o),sn=l(a),mn=$(a,"HR",{class:!0}),ln=l(a),fn=$(a,"P",{"data-svelte-h":!0}),"svelte-gyipz4"!==m(fn)&&(fn.innerHTML=Ce),on=l(a),gn=$(a,"P",{});var r=s(gn);un=f(r,"このプログラムでは、"),b(pn.$$.fragment,r),cn=f(r," で関数を定義しています。\n      "),dn=$(r,"BR",{}),hn=l(r),b(wn.$$.fragment,r),bn=f(r," は関数を表しており、\n      "),b(vn.$$.fragment,r),xn=f(r," は関数の名前です。\n      "),Bn=$(r,"BR",{}),Rn=f(r,"\n      この関数は、引数"),b(Cn.$$.fragment,r),En=f(r," を受け取り、その値を2倍にして返します。"),r.forEach(o),Pn=l(a),Hn=$(a,"HR",{class:!0}),Ln=l(a),jn=$(a,"P",{});var g=s(jn);kn=f(g,"では、このプログラムを実行してみましょう。 "),Sn=$(g,"BR",{}),In=f(g,"\n      変数"),b(yn.$$.fragment,g),Dn=f(g," が、関数"),b(Tn.$$.fragment,g),Vn=f(g," によって変化していく様子がわかるでしょうか？\n      "),zn=$(g,"BR",{}),Kn=f(g,"\n      （ヒント："),Mn=$(g,"SPAN",{class:!0,"data-svelte-h":!0}),"svelte-76rfbh"!==m(Mn)&&(Mn.textContent=Ee),On=f(g," で、実行中の値の変化を確認できます）"),g.forEach(o),qn=l(a),An=$(a,"HR",{class:!0}),a.forEach(o),Gn=l(e),b(Nn.$$.fragment,e),Jn=l(e),Qn=$(e,"DIV",{class:!0});var u=s(Qn);Un=$(u,"HR",{class:!0}),Wn=l(u),Xn=$(u,"P",{});var p=s(Xn);Yn=f(p,"実は、変数は 2種類あります。それは "),b(Zn.$$.fragment,p),_n=f(p," と\n      "),b(ne.$$.fragment,p),ee=f(p," です。\n      "),ae=$(p,"BR",{}),te=l(p),b(re.$$.fragment,p),$e=f(p," は何度でも代入でき、値を書き換えることができる変数です。\n      "),se=$(p,"BR",{}),me=f(p,"\n      一方で、"),b(le.$$.fragment,p),fe=f(p," は一度しか代入できず、値を書き換えることができない変数です。\n      "),oe=$(p,"BR",{}),ge=f(p,"\n      このプログラムでは "),b(ue.$$.fragment,p),pe=f(p," で変数を定義していますが、\n      "),ce=$(p,"BR",{}),de=f(p,"\n      もし、これを "),b(ie.$$.fragment,p),he=f(p," に変更してから実行したら、結果はどうなるでしょうか？"),p.forEach(o),we=l(u),be=$(u,"HR",{class:!0}),u.forEach(o),e.forEach(o),this.h()},h(){g(i,"class","cLessonTitle"),g(L,"class","cBorderLine"),g(I,"class","cBorderLine"),g(mn,"class","cBorderLine"),g(Hn,"class","cBorderLine"),g(Mn,"class","cIndexSpan"),g(An,"class","cBorderLine"),g(H,"class","w-full"),g(Un,"class","cBorderLine"),g(be,"class","cBorderLine"),g(Qn,"class","w-full"),g(d,"class","cBookContents")},m(n,e){u(n,d,e),p(d,i),p(d,P),p(d,H),p(H,L),p(H,j),p(H,k),p(H,S),p(H,I),p(H,y),p(H,D),p(H,T),p(H,V),p(V,z),v(K,V,null),p(V,M),v(O,V,null),p(V,q),v(A,V,null),p(V,G),p(V,N),p(V,F),v(J,V,null),p(V,Q),p(V,U),p(V,W),v(X,V,null),p(V,Y),v(Z,V,null),p(V,_),v(nn,V,null),p(V,en),p(V,an),p(V,tn),v(rn,V,null),p(V,$n),p(H,sn),p(H,mn),p(H,ln),p(H,fn),p(H,on),p(H,gn),p(gn,un),v(pn,gn,null),p(gn,cn),p(gn,dn),p(gn,hn),v(wn,gn,null),p(gn,bn),v(vn,gn,null),p(gn,xn),p(gn,Bn),p(gn,Rn),v(Cn,gn,null),p(gn,En),p(H,Pn),p(H,Hn),p(H,Ln),p(H,jn),p(jn,kn),p(jn,Sn),p(jn,In),v(yn,jn,null),p(jn,Dn),v(Tn,jn,null),p(jn,Vn),p(jn,zn),p(jn,Kn),p(jn,Mn),p(jn,On),p(H,qn),p(H,An),p(d,Gn),v(Nn,d,null),p(d,Jn),p(d,Qn),p(Qn,Un),p(Qn,Wn),p(Qn,Xn),p(Xn,Yn),v(Zn,Xn,null),p(Xn,_n),v(ne,Xn,null),p(Xn,ee),p(Xn,ae),p(Xn,te),v(re,Xn,null),p(Xn,$e),p(Xn,se),p(Xn,me),v(le,Xn,null),p(Xn,fe),p(Xn,oe),p(Xn,ge),v(ue,Xn,null),p(Xn,pe),p(Xn,ce),p(Xn,de),v(ie,Xn,null),p(Xn,he),p(Qn,we),p(Qn,be),ve=!0},p(n,[e]){const a={};!Fn&&2&e&&(Fn=!0,a.codeExeProps=n[1],c((()=>Fn=!1))),Nn.$set(a)},i(n){ve||(x(K.$$.fragment,n),x(O.$$.fragment,n),x(A.$$.fragment,n),x(J.$$.fragment,n),x(X.$$.fragment,n),x(Z.$$.fragment,n),x(nn.$$.fragment,n),x(rn.$$.fragment,n),x(pn.$$.fragment,n),x(wn.$$.fragment,n),x(vn.$$.fragment,n),x(Cn.$$.fragment,n),x(yn.$$.fragment,n),x(Tn.$$.fragment,n),x(Nn.$$.fragment,n),x(Zn.$$.fragment,n),x(ne.$$.fragment,n),x(re.$$.fragment,n),x(le.$$.fragment,n),x(ue.$$.fragment,n),x(ie.$$.fragment,n),ve=!0)},o(n){B(K.$$.fragment,n),B(O.$$.fragment,n),B(A.$$.fragment,n),B(J.$$.fragment,n),B(X.$$.fragment,n),B(Z.$$.fragment,n),B(nn.$$.fragment,n),B(rn.$$.fragment,n),B(pn.$$.fragment,n),B(wn.$$.fragment,n),B(vn.$$.fragment,n),B(Cn.$$.fragment,n),B(yn.$$.fragment,n),B(Tn.$$.fragment,n),B(Nn.$$.fragment,n),B(Zn.$$.fragment,n),B(ne.$$.fragment,n),B(re.$$.fragment,n),B(le.$$.fragment,n),B(ue.$$.fragment,n),B(ie.$$.fragment,n),ve=!1},d(e){e&&o(d),R(K),R(O),R(A),R(J),R(X),R(Z),R(nn),R(rn),R(pn),R(wn),R(vn),R(Cn),R(yn),R(Tn),n[2](null),R(Nn),R(Zn),R(ne),R(re),R(le),R(ue),R(ie)}}}function H(n,a,t){let r,$={allowedGlobals:{},code:'function double(arg) {\n  return arg * 2;\n}\n\nlet num = 10;\nlog("num1: " + num);\nnum = double(num);\nlog("num2: " + num);\nnum = double(num);\nlog("num3: " + num);\n\nreturn num;',resultString:"",logs:[]};return[r,$,function(n){e[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){$=n,t(1,$)}]}class L extends d{constructor(e){super(),i(this,e,H,P,n,{})}}export{L as component};
