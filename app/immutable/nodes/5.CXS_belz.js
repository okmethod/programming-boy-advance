import{s as n,e,c as t,b as r,g as a,h as s,i as l,n as $,t as o,d as f,j as c,k as m,r as g,u as i,m as u,a as p,o as h,f as d,p as w,G as v,L as b,V as x}from"../chunks/scheduler.DDBKXN7T.js";import{S as B,i as E,b as R,c as L,a as P,m as H,t as C,d as I,e as V,g as D,f as S}from"../chunks/index.DYJ5--4d.js";import{e as k}from"../chunks/each.Dx_PCbEy.js";import"../chunks/ProgressBar.svelte_svelte_type_style_lang.CYOtRnvQ.js";import{T as y,a as T}from"../chunks/Tab.DTrcPhO6.js";import{C as N}from"../chunks/CodeExecuter.EAcoXtKi.js";import{n as j}from"../chunks/navigation.client.Drn8GY5S.js";function A(n,e,t){const r=n.slice();return r[2]=e[t][0],r[3]=e[t][1],r}function G(n){let $,g,i,u=n[0][0]+"";return{c(){$=e("span"),g=o(u),this.h()},l(n){$=t(n,"SPAN",{class:!0});var e=r($);g=f(e,u),e.forEach(a),this.h()},h(){s($,"class",i=n[1](n[0][1]))},m(n,e){l(n,$,e),c($,g)},p(n,e){1&e&&u!==(u=n[0][0]+"")&&m(g,u),1&e&&i!==(i=n[1](n[0][1]))&&s($,"class",i)},d(n){n&&a($)}}}function M(n){let e,t=k(n[0]),r=[];for(let a=0;a<t.length;a+=1)r[a]=_(A(n,t,a));return{c(){for(let n=0;n<r.length;n+=1)r[n].c();e=g()},l(n){for(let e=0;e<r.length;e+=1)r[e].l(n);e=g()},m(n,t){for(let e=0;e<r.length;e+=1)r[e]&&r[e].m(n,t);l(n,e,t)},p(n,a){if(3&a){let s;for(t=k(n[0]),s=0;s<t.length;s+=1){const l=A(n,t,s);r[s]?r[s].p(l,a):(r[s]=_(l),r[s].c(),r[s].m(e.parentNode,e))}for(;s<r.length;s+=1)r[s].d(1);r.length=t.length}},d(n){n&&a(e),i(r,n)}}}function _(n){let $,g,i,u=n[2]+"";return{c(){$=e("span"),g=o(u),this.h()},l(n){$=t(n,"SPAN",{class:!0});var e=r($);g=f(e,u),e.forEach(a),this.h()},h(){s($,"class",i=n[1](n[3]))},m(n,e){l(n,$,e),c($,g)},p(n,e){1&e&&u!==(u=n[2]+"")&&m(g,u),1&e&&i!==(i=n[1](n[3]))&&s($,"class",i)},d(n){n&&a($)}}}function q(n){let o,f;function c(n,e){var t;return 1&e&&(f=null),null==f&&(t=n[0],f=!(!Array.isArray(t)||!Array.isArray(t[0]))),f?M:G}let m=c(n,-1),g=m(n);return{c(){o=e("span"),g.c(),this.h()},l(n){o=t(n,"SPAN",{class:!0});var e=r(o);g.l(e),e.forEach(a),this.h()},h(){s(o,"class","px-1 font-mono bg-gray-800 rounded")},m(n,e){l(n,o,e),g.m(o,null)},p(n,[e]){m===(m=c(n,e))&&g?g.p(n,e):(g.d(1),g=m(n),g&&(g.c(),g.m(o,null)))},i:$,o:$,d(n){n&&a(o),g.d()}}}function z(n,e,t){let{data:r}=e;return n.$$set=n=>{"data"in n&&t(0,r=n.data)},[r,n=>({red:"hljs-keyword",lightblue:"hljs-string",blue:"hljs-number",purple:"hljs-title",white:"text-gray-200"}[n]||n)]}class O extends B{constructor(e){super(),E(this,e,z,q,n,{data:0})}}function W(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn="プログラムの基礎 Lesson1 : プログラムを実行してみよう！",hn='画面左側の <span class="cIndexSpan">Code Editor</span> に書かれたプログラムを、 画面中央の\n      <span class="cIconButtonStyle hover:!bg-green-800">Execute</span> ボタンを押して実行してみましょう。',dn="Result",wn="logs";function vn(e){n[4](e)}S=new O({props:{data:["return","red"]}}),M=new O({props:{data:[["log","purple"],["()","white"]]}});let bn={allowedGlobals:n[2]};return void 0!==n[1]&&(bn.codeExeProps=n[1]),K=new N({props:bn}),n[3](K),u.push((()=>R(K,"codeExeProps",vn))),sn=new O({props:{data:[["const ","red"],["str","white"]]}}),$n=new O({props:{data:["Hello, World!","hljs-string"]}}),{c(){$=e("div"),m=e("h2"),m.textContent=pn,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),x.innerHTML=hn,B=p(),E=e("p"),D=o("プログラムを実行すると、\n      "),L(S.$$.fragment),k=o(" が結果を出力します。 結果は、画面右側の\n      "),y=e("span"),y.textContent=dn,T=o(" に表示されます。"),j=p(),A=e("p"),G=o("また、実行中に "),L(M.$$.fragment),_=o(" がログを出力します。 ログは、画面右側の\n      "),q=e("span"),q.textContent=wn,z=o(" に表示されます。"),W=p(),U=e("hr"),F=p(),J=e("div"),L(K.$$.fragment),X=p(),Y=e("div"),Z=e("hr"),nn=p(),en=e("p"),tn=o("もちろん、プログラムは書き換えることができます。\n      "),rn=e("br"),an=o("\n      例えば、このプログラムでは "),L(sn.$$.fragment),ln=o(" という変数に\n      "),L($n.$$.fragment),on=o(" という文字列を代入しています。\n      "),fn=e("br"),cn=o("\n      もし、この文字列を書き換えてから実行したら、結果はどうなるでしょうか？"),mn=p(),gn=e("hr"),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-1mbuw9m"!==h(m)&&(m.textContent=pn),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{"data-svelte-h":!0}),"svelte-dca7tk"!==h(x)&&(x.innerHTML=hn),B=d(s),E=t(s,"P",{});var l=r(E);D=f(l,"プログラムを実行すると、\n      "),P(S.$$.fragment,l),k=f(l," が結果を出力します。 結果は、画面右側の\n      "),y=t(l,"SPAN",{class:!0,"data-svelte-h":!0}),"svelte-endztj"!==h(y)&&(y.textContent=dn),T=f(l," に表示されます。"),l.forEach(a),j=d(s),A=t(s,"P",{});var o=r(A);G=f(o,"また、実行中に "),P(M.$$.fragment,o),_=f(o," がログを出力します。 ログは、画面右側の\n      "),q=t(o,"SPAN",{class:!0,"data-svelte-h":!0}),"svelte-76rfbh"!==h(q)&&(q.textContent=wn),z=f(o," に表示されます。"),o.forEach(a),W=d(s),U=t(s,"HR",{class:!0}),s.forEach(a),F=d(e),J=t(e,"DIV",{class:!0});var c=r(J);P(K.$$.fragment,c),c.forEach(a),X=d(e),Y=t(e,"DIV",{});var u=r(Y);Z=t(u,"HR",{class:!0}),nn=d(u),en=t(u,"P",{});var p=r(en);tn=f(p,"もちろん、プログラムは書き換えることができます。\n      "),rn=t(p,"BR",{}),an=f(p,"\n      例えば、このプログラムでは "),P(sn.$$.fragment,p),ln=f(p," という変数に\n      "),P($n.$$.fragment,p),on=f(p," という文字列を代入しています。\n      "),fn=t(p,"BR",{}),cn=f(p,"\n      もし、この文字列を書き換えてから実行したら、結果はどうなるでしょうか？"),p.forEach(a),mn=d(u),gn=t(u,"HR",{class:!0}),u.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(y,"class","cIndexSpan"),s(q,"class","cIndexSpan"),s(U,"class","cBorderLine"),s(J,"class","cResponsiveCodeExecuter"),s(Z,"class","cBorderLine"),s(gn,"class","cBorderLine"),s($,"class","max-w-[1000px]")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(i,B),c(i,E),c(E,D),H(S,E,null),c(E,k),c(E,y),c(E,T),c(i,j),c(i,A),c(A,G),H(M,A,null),c(A,_),c(A,q),c(A,z),c(i,W),c(i,U),c($,F),c($,J),H(K,J,null),c($,X),c($,Y),c(Y,Z),c(Y,nn),c(Y,en),c(en,tn),c(en,rn),c(en,an),H(sn,en,null),c(en,ln),H($n,en,null),c(en,on),c(en,fn),c(en,cn),c(Y,mn),c(Y,gn),un=!0},p(n,[e]){const t={};!Q&&2&e&&(Q=!0,t.codeExeProps=n[1],w((()=>Q=!1))),K.$set(t)},i(n){un||(C(S.$$.fragment,n),C(M.$$.fragment,n),C(K.$$.fragment,n),C(sn.$$.fragment,n),C($n.$$.fragment,n),un=!0)},o(n){I(S.$$.fragment,n),I(M.$$.fragment,n),I(K.$$.fragment,n),I(sn.$$.fragment,n),I($n.$$.fragment,n),un=!1},d(e){e&&a($),V(S),V(M),n[3](null),V(K),V(sn),V($n)}}}function U(n,e,t){let r,a={code:'const str = "Hello, World!";\nlog("log: " + str);\nreturn str;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class F extends B{constructor(e){super(),E(this,e,U,W,n,{})}}function J(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn,xn,Bn,En,Rn,Ln,Pn,Hn,Cn,In,Vn,Dn,Sn,kn,yn,Tn,Nn,jn,An,Gn,Mn,_n,qn,zn,On,Wn,Un,Fn,Jn,Kn,Qn,Xn,Yn,Zn,ne,ee,te,re,ae,se,le,$e,oe,fe,ce="プログラムの基礎 Lesson2 : 変数 と 関数",me="プログラムには、2つの重要なアイテムがあります。それは「変数」と「関数」です。",ge="「変数」は、「データ」を保存するための箱のようなものです。 データを変数に保存することを、「代入する」とよびます。",ie="「関数」は、「操作」を保存するための箱のようなものです。\n      関数を呼び出すことで、それらの操作をまとめて実行できます。\n      <br/>\n      関数に渡すデータを「引数」とよび、関数から返されるデータを「戻り値」とよびます。",ue="logs";function pe(e){n[4](e)}j=new O({props:{data:[["let ","red"],["number","white"]]}}),G=new O({props:{data:["let","red"]}}),_=new O({props:{data:["number","white"]}}),U=new O({props:{data:["10","blue"]}}),en=new O({props:{data:[["function ","red"],["double","purple"],["()","white"]]}}),sn=new O({props:{data:["function","red"]}}),$n=new O({props:{data:["double","purple"]}}),mn=new O({props:{data:["num","white"]}}),xn=new O({props:{data:["number","white"]}}),En=new O({props:{data:["double","purple"]}});let he={allowedGlobals:n[2]};return void 0!==n[1]&&(he.codeExeProps=n[1]),kn=new N({props:he}),n[3](kn),u.push((()=>R(kn,"codeExeProps",pe))),_n=new O({props:{data:["let","red"]}}),zn=new O({props:{data:["const","red"]}}),Fn=new O({props:{data:["let","red"]}}),Xn=new O({props:{data:["const","red"]}}),ee=new O({props:{data:[["let ","red"],["number","white"]]}}),se=new O({props:{data:[["const ","red"],["number","white"]]}}),{c(){$=e("div"),m=e("h2"),m.textContent=ce,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),x.textContent=me,B=p(),E=e("hr"),D=p(),S=e("p"),S.textContent=ge,k=p(),y=e("p"),T=o("このプログラムでは、"),L(j.$$.fragment),A=o(" で変数を定義しています。\n      "),L(G.$$.fragment),M=o(" は変数の種類で、\n      "),L(_.$$.fragment),q=o(" は変数の名前です。\n      "),z=e("br"),W=o("\n      この変数に "),L(U.$$.fragment),F=o(" という数値を代入しています。"),J=p(),K=e("hr"),Q=p(),X=e("p"),X.innerHTML=ie,Y=p(),Z=e("p"),nn=o("このプログラムでは、"),L(en.$$.fragment),tn=o(" で関数を定義しています。\n      "),rn=e("br"),an=p(),L(sn.$$.fragment),ln=o(" は関数を表しており、\n      "),L($n.$$.fragment),on=o(" は関数の名前です。\n      "),fn=e("br"),cn=o("\n      この関数は、引数"),L(mn.$$.fragment),gn=o(" を受け取り、その値を2倍にして返します。"),un=p(),pn=e("hr"),hn=p(),dn=e("p"),wn=o("では、このプログラムを実行してみましょう。 "),vn=e("br"),bn=o("\n      変数"),L(xn.$$.fragment),Bn=o(" が、関数"),L(En.$$.fragment),Rn=o(" によって変化していく様子がわかるでしょうか？\n      "),Ln=e("br"),Pn=o("\n      （ヒント："),Hn=e("span"),Hn.textContent=ue,Cn=o(" で、実行中の値の変化を確認できます）"),In=p(),Vn=e("hr"),Dn=p(),Sn=e("div"),L(kn.$$.fragment),Tn=p(),Nn=e("div"),jn=e("hr"),An=p(),Gn=e("p"),Mn=o("実は、変数は 2種類あります。それは "),L(_n.$$.fragment),qn=o(" と\n      "),L(zn.$$.fragment),On=o(" です。\n      "),Wn=e("br"),Un=p(),L(Fn.$$.fragment),Jn=o(" は何度でも代入でき、値を書き換えることができる変数です。\n      "),Kn=e("br"),Qn=o("\n      一方で、"),L(Xn.$$.fragment),Yn=o(" は一度しか代入できず、値を書き換えることができない変数です。\n      "),Zn=e("br"),ne=o("\n      このプログラムでは "),L(ee.$$.fragment),te=o(" で変数を定義していますが、\n      "),re=e("br"),ae=o("\n      もし、これを "),L(se.$$.fragment),le=o(" に変更してから実行したら、結果はどうなるでしょうか？"),$e=p(),oe=e("hr"),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-py46n7"!==h(m)&&(m.textContent=ce),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{"data-svelte-h":!0}),"svelte-1p11vxu"!==h(x)&&(x.textContent=me),B=d(s),E=t(s,"HR",{class:!0}),D=d(s),S=t(s,"P",{"data-svelte-h":!0}),"svelte-yi6x0d"!==h(S)&&(S.textContent=ge),k=d(s),y=t(s,"P",{});var l=r(y);T=f(l,"このプログラムでは、"),P(j.$$.fragment,l),A=f(l," で変数を定義しています。\n      "),P(G.$$.fragment,l),M=f(l," は変数の種類で、\n      "),P(_.$$.fragment,l),q=f(l," は変数の名前です。\n      "),z=t(l,"BR",{}),W=f(l,"\n      この変数に "),P(U.$$.fragment,l),F=f(l," という数値を代入しています。"),l.forEach(a),J=d(s),K=t(s,"HR",{class:!0}),Q=d(s),X=t(s,"P",{"data-svelte-h":!0}),"svelte-gyipz4"!==h(X)&&(X.innerHTML=ie),Y=d(s),Z=t(s,"P",{});var o=r(Z);nn=f(o,"このプログラムでは、"),P(en.$$.fragment,o),tn=f(o," で関数を定義しています。\n      "),rn=t(o,"BR",{}),an=d(o),P(sn.$$.fragment,o),ln=f(o," は関数を表しており、\n      "),P($n.$$.fragment,o),on=f(o," は関数の名前です。\n      "),fn=t(o,"BR",{}),cn=f(o,"\n      この関数は、引数"),P(mn.$$.fragment,o),gn=f(o," を受け取り、その値を2倍にして返します。"),o.forEach(a),un=d(s),pn=t(s,"HR",{class:!0}),hn=d(s),dn=t(s,"P",{});var c=r(dn);wn=f(c,"では、このプログラムを実行してみましょう。 "),vn=t(c,"BR",{}),bn=f(c,"\n      変数"),P(xn.$$.fragment,c),Bn=f(c," が、関数"),P(En.$$.fragment,c),Rn=f(c," によって変化していく様子がわかるでしょうか？\n      "),Ln=t(c,"BR",{}),Pn=f(c,"\n      （ヒント："),Hn=t(c,"SPAN",{class:!0,"data-svelte-h":!0}),"svelte-76rfbh"!==h(Hn)&&(Hn.textContent=ue),Cn=f(c," で、実行中の値の変化を確認できます）"),c.forEach(a),In=d(s),Vn=t(s,"HR",{class:!0}),s.forEach(a),Dn=d(e),Sn=t(e,"DIV",{class:!0});var u=r(Sn);P(kn.$$.fragment,u),u.forEach(a),Tn=d(e),Nn=t(e,"DIV",{});var p=r(Nn);jn=t(p,"HR",{class:!0}),An=d(p),Gn=t(p,"P",{});var w=r(Gn);Mn=f(w,"実は、変数は 2種類あります。それは "),P(_n.$$.fragment,w),qn=f(w," と\n      "),P(zn.$$.fragment,w),On=f(w," です。\n      "),Wn=t(w,"BR",{}),Un=d(w),P(Fn.$$.fragment,w),Jn=f(w," は何度でも代入でき、値を書き換えることができる変数です。\n      "),Kn=t(w,"BR",{}),Qn=f(w,"\n      一方で、"),P(Xn.$$.fragment,w),Yn=f(w," は一度しか代入できず、値を書き換えることができない変数です。\n      "),Zn=t(w,"BR",{}),ne=f(w,"\n      このプログラムでは "),P(ee.$$.fragment,w),te=f(w," で変数を定義していますが、\n      "),re=t(w,"BR",{}),ae=f(w,"\n      もし、これを "),P(se.$$.fragment,w),le=f(w," に変更してから実行したら、結果はどうなるでしょうか？"),w.forEach(a),$e=d(p),oe=t(p,"HR",{class:!0}),p.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(E,"class","cBorderLine"),s(K,"class","cBorderLine"),s(pn,"class","cBorderLine"),s(Hn,"class","cIndexSpan"),s(Vn,"class","cBorderLine"),s(Sn,"class","cResponsiveCodeExecuter"),s(jn,"class","cBorderLine"),s(oe,"class","cBorderLine"),s($,"class","max-w-[1000px]")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(i,B),c(i,E),c(i,D),c(i,S),c(i,k),c(i,y),c(y,T),H(j,y,null),c(y,A),H(G,y,null),c(y,M),H(_,y,null),c(y,q),c(y,z),c(y,W),H(U,y,null),c(y,F),c(i,J),c(i,K),c(i,Q),c(i,X),c(i,Y),c(i,Z),c(Z,nn),H(en,Z,null),c(Z,tn),c(Z,rn),c(Z,an),H(sn,Z,null),c(Z,ln),H($n,Z,null),c(Z,on),c(Z,fn),c(Z,cn),H(mn,Z,null),c(Z,gn),c(i,un),c(i,pn),c(i,hn),c(i,dn),c(dn,wn),c(dn,vn),c(dn,bn),H(xn,dn,null),c(dn,Bn),H(En,dn,null),c(dn,Rn),c(dn,Ln),c(dn,Pn),c(dn,Hn),c(dn,Cn),c(i,In),c(i,Vn),c($,Dn),c($,Sn),H(kn,Sn,null),c($,Tn),c($,Nn),c(Nn,jn),c(Nn,An),c(Nn,Gn),c(Gn,Mn),H(_n,Gn,null),c(Gn,qn),H(zn,Gn,null),c(Gn,On),c(Gn,Wn),c(Gn,Un),H(Fn,Gn,null),c(Gn,Jn),c(Gn,Kn),c(Gn,Qn),H(Xn,Gn,null),c(Gn,Yn),c(Gn,Zn),c(Gn,ne),H(ee,Gn,null),c(Gn,te),c(Gn,re),c(Gn,ae),H(se,Gn,null),c(Gn,le),c(Nn,$e),c(Nn,oe),fe=!0},p(n,[e]){const t={};!yn&&2&e&&(yn=!0,t.codeExeProps=n[1],w((()=>yn=!1))),kn.$set(t)},i(n){fe||(C(j.$$.fragment,n),C(G.$$.fragment,n),C(_.$$.fragment,n),C(U.$$.fragment,n),C(en.$$.fragment,n),C(sn.$$.fragment,n),C($n.$$.fragment,n),C(mn.$$.fragment,n),C(xn.$$.fragment,n),C(En.$$.fragment,n),C(kn.$$.fragment,n),C(_n.$$.fragment,n),C(zn.$$.fragment,n),C(Fn.$$.fragment,n),C(Xn.$$.fragment,n),C(ee.$$.fragment,n),C(se.$$.fragment,n),fe=!0)},o(n){I(j.$$.fragment,n),I(G.$$.fragment,n),I(_.$$.fragment,n),I(U.$$.fragment,n),I(en.$$.fragment,n),I(sn.$$.fragment,n),I($n.$$.fragment,n),I(mn.$$.fragment,n),I(xn.$$.fragment,n),I(En.$$.fragment,n),I(kn.$$.fragment,n),I(_n.$$.fragment,n),I(zn.$$.fragment,n),I(Fn.$$.fragment,n),I(Xn.$$.fragment,n),I(ee.$$.fragment,n),I(se.$$.fragment,n),fe=!1},d(e){e&&a($),V(j),V(G),V(_),V(U),V(en),V(sn),V($n),V(mn),V(xn),V(En),n[3](null),V(kn),V(_n),V(zn),V(Fn),V(Xn),V(ee),V(se)}}}function K(n,e,t){let r,a={code:'function double(num) {\n  return num * 2;\n}\n\nlet number = 10;\nlog("number: " + number);\nnumber = double(number);\nlog("number: " + number);\nnumber = double(number);\nlog("number: " + number);\n\nreturn number;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class Q extends B{constructor(e){super(),E(this,e,K,J,n,{})}}function X(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn,xn,Bn,En,Rn,Ln,Pn,Hn,Cn,In,Vn,Dn,Sn,kn,yn,Tn,Nn,jn,An,Gn="プログラムの基礎 Lesson3 : データの型";function Mn(e){n[4](e)}S=new O({props:{data:["Number","white"]}}),y=new O({props:{data:["String","white"]}}),q=new O({props:{data:['""',"lightblue"]}}),Q=new O({props:{data:["num","white"]}}),Y=new O({props:{data:["str","white"]}});let _n={allowedGlobals:n[2]};return void 0!==n[1]&&(_n.codeExeProps=n[1]),an=new N({props:_n}),n[3](an),u.push((()=>R(an,"codeExeProps",Mn))),gn=new O({props:{data:["+","white"]}}),dn=new O({props:{data:["num + num","white"]}}),vn=new O({props:{data:["str + str","white"]}}),En=new O({props:{data:["str + num","white"]}}),Vn=new O({props:{data:["-","white"]}}),Sn=new O({props:{data:["str - num","white"]}}),{c(){$=e("div"),m=e("h2"),m.textContent=Gn,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),B=o("変数には様々なデータを代入することができます。データの種類を「型」とよびます。\n      "),E=e("br"),D=o("\n      型には様々な種類があり、たとえば「数値型("),L(S.$$.fragment),k=o(")」や「文字列型("),L(y.$$.fragment),T=o(")」があります。"),j=p(),A=e("hr"),G=p(),M=e("p"),_=o("数字は、囲み文字"),L(q.$$.fragment),z=o("で囲むと文字列型になり、囲まないと数値型として扱われます。\n      "),W=e("br"),U=o("\n      数字以外の文字を含む場合は、囲むと文字列型になり、囲まないと変数として扱われます。"),F=p(),J=e("p"),K=o("このプログラムを実行して、"),L(Q.$$.fragment),X=o(" と "),L(Y.$$.fragment),Z=o(" がどのように扱われるか見てみましょう。"),nn=p(),en=e("hr"),tn=p(),rn=e("div"),L(an.$$.fragment),ln=p(),$n=e("div"),on=e("hr"),fn=p(),cn=e("p"),mn=o("また、"),L(gn.$$.fragment),un=o(" のような操作を「演算子」とよびますが、データの型によって演算子の効果が変わることがあります。\n      "),pn=e("br"),hn=o("\n      例えば、数値型同士を "),L(dn.$$.fragment),wn=o(" すると足し算をしますが、文字列型同士を "),L(vn.$$.fragment),bn=o(" すると文字列をつなぎます。\n      "),xn=e("br"),Bn=o("\n      そして、文字列型と数値型を "),L(En.$$.fragment),Rn=o(" すると、数値型が文字列型に変換され、文字列としてつなぎます。"),Ln=p(),Pn=e("hr"),Hn=p(),Cn=e("p"),In=o("では、演算子 "),L(Vn.$$.fragment),Dn=o(" を使うとどうなるでしょう？\n      "),L(Sn.$$.fragment),kn=o(" に書き換えて実行してみましょう。\n      "),yn=e("br"),Tn=o("\n      結果は予想通りでしたか？それとも不思議な結果でしたか？"),Nn=p(),jn=e("hr"),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-a2rkl4"!==h(m)&&(m.textContent=Gn),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{});var l=r(x);B=f(l,"変数には様々なデータを代入することができます。データの種類を「型」とよびます。\n      "),E=t(l,"BR",{}),D=f(l,"\n      型には様々な種類があり、たとえば「数値型("),P(S.$$.fragment,l),k=f(l,")」や「文字列型("),P(y.$$.fragment,l),T=f(l,")」があります。"),l.forEach(a),j=d(s),A=t(s,"HR",{class:!0}),G=d(s),M=t(s,"P",{});var o=r(M);_=f(o,"数字は、囲み文字"),P(q.$$.fragment,o),z=f(o,"で囲むと文字列型になり、囲まないと数値型として扱われます。\n      "),W=t(o,"BR",{}),U=f(o,"\n      数字以外の文字を含む場合は、囲むと文字列型になり、囲まないと変数として扱われます。"),o.forEach(a),F=d(s),J=t(s,"P",{});var c=r(J);K=f(c,"このプログラムを実行して、"),P(Q.$$.fragment,c),X=f(c," と "),P(Y.$$.fragment,c),Z=f(c," がどのように扱われるか見てみましょう。"),c.forEach(a),nn=d(s),en=t(s,"HR",{class:!0}),s.forEach(a),tn=d(e),rn=t(e,"DIV",{class:!0});var u=r(rn);P(an.$$.fragment,u),u.forEach(a),ln=d(e),$n=t(e,"DIV",{});var p=r($n);on=t(p,"HR",{class:!0}),fn=d(p),cn=t(p,"P",{});var w=r(cn);mn=f(w,"また、"),P(gn.$$.fragment,w),un=f(w," のような操作を「演算子」とよびますが、データの型によって演算子の効果が変わることがあります。\n      "),pn=t(w,"BR",{}),hn=f(w,"\n      例えば、数値型同士を "),P(dn.$$.fragment,w),wn=f(w," すると足し算をしますが、文字列型同士を "),P(vn.$$.fragment,w),bn=f(w," すると文字列をつなぎます。\n      "),xn=t(w,"BR",{}),Bn=f(w,"\n      そして、文字列型と数値型を "),P(En.$$.fragment,w),Rn=f(w," すると、数値型が文字列型に変換され、文字列としてつなぎます。"),w.forEach(a),Ln=d(p),Pn=t(p,"HR",{class:!0}),Hn=d(p),Cn=t(p,"P",{});var R=r(Cn);In=f(R,"では、演算子 "),P(Vn.$$.fragment,R),Dn=f(R," を使うとどうなるでしょう？\n      "),P(Sn.$$.fragment,R),kn=f(R," に書き換えて実行してみましょう。\n      "),yn=t(R,"BR",{}),Tn=f(R,"\n      結果は予想通りでしたか？それとも不思議な結果でしたか？"),R.forEach(a),Nn=d(p),jn=t(p,"HR",{class:!0}),p.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(A,"class","cBorderLine"),s(en,"class","cBorderLine"),s(rn,"class","cResponsiveCodeExecuter"),s(on,"class","cBorderLine"),s(Pn,"class","cBorderLine"),s(jn,"class","cBorderLine"),s($,"class","max-w-[1000px]")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(x,B),c(x,E),c(x,D),H(S,x,null),c(x,k),H(y,x,null),c(x,T),c(i,j),c(i,A),c(i,G),c(i,M),c(M,_),H(q,M,null),c(M,z),c(M,W),c(M,U),c(i,F),c(i,J),c(J,K),H(Q,J,null),c(J,X),H(Y,J,null),c(J,Z),c(i,nn),c(i,en),c($,tn),c($,rn),H(an,rn,null),c($,ln),c($,$n),c($n,on),c($n,fn),c($n,cn),c(cn,mn),H(gn,cn,null),c(cn,un),c(cn,pn),c(cn,hn),H(dn,cn,null),c(cn,wn),H(vn,cn,null),c(cn,bn),c(cn,xn),c(cn,Bn),H(En,cn,null),c(cn,Rn),c($n,Ln),c($n,Pn),c($n,Hn),c($n,Cn),c(Cn,In),H(Vn,Cn,null),c(Cn,Dn),H(Sn,Cn,null),c(Cn,kn),c(Cn,yn),c(Cn,Tn),c($n,Nn),c($n,jn),An=!0},p(n,[e]){const t={};!sn&&2&e&&(sn=!0,t.codeExeProps=n[1],w((()=>sn=!1))),an.$set(t)},i(n){An||(C(S.$$.fragment,n),C(y.$$.fragment,n),C(q.$$.fragment,n),C(Q.$$.fragment,n),C(Y.$$.fragment,n),C(an.$$.fragment,n),C(gn.$$.fragment,n),C(dn.$$.fragment,n),C(vn.$$.fragment,n),C(En.$$.fragment,n),C(Vn.$$.fragment,n),C(Sn.$$.fragment,n),An=!0)},o(n){I(S.$$.fragment,n),I(y.$$.fragment,n),I(q.$$.fragment,n),I(Q.$$.fragment,n),I(Y.$$.fragment,n),I(an.$$.fragment,n),I(gn.$$.fragment,n),I(dn.$$.fragment,n),I(vn.$$.fragment,n),I(En.$$.fragment,n),I(Vn.$$.fragment,n),I(Sn.$$.fragment,n),An=!1},d(e){e&&a($),V(S),V(y),V(q),V(Q),V(Y),n[3](null),V(an),V(gn),V(dn),V(vn),V(En),V(Vn),V(Sn)}}}function Y(n,e,t){let r,a={code:'const num = 10;\nlog("number: " + num);\nlog(\'"number": \' + "num");\nlog("number+: " + (num + num));\n\nconst str = "100";\nlog("string: " + str);\nlog(\'"string": \' + "str");\nlog("string+: " + (str + str));\n\nreturn str + num;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class Z extends B{constructor(e){super(),E(this,e,Y,X,n,{})}}function nn(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn,xn,Bn,En,Rn,Ln,Pn,Hn,Cn,In,Vn,Dn,Sn,kn,yn,Tn,Nn,jn,An,Gn,Mn,_n,qn,zn,On,Wn,Un,Fn,Jn="プログラムの基礎 Lesson4 : データの配列",Kn="配列は、数値型のデータだけでなく、様々な型のデータを要素として入れることができます。";function Qn(e){n[4](e)}E=new O({props:{data:["Array","white"]}}),y=new O({props:{data:["[]","white"]}}),j=new O({props:{data:[",","white"]}}),K=new O({props:{data:[["list[","white"],["0","blue"],["]","white"]]}}),Z=new O({props:{data:["list.length","white"]}});let Xn={allowedGlobals:n[2]};return void 0!==n[1]&&(Xn.codeExeProps=n[1]),$n=new N({props:Xn}),n[3]($n),u.push((()=>R($n,"codeExeProps",Qn))),Bn=new O({props:{data:["linl","white"]}}),Pn=new O({props:{data:["linl[0]","white"]}}),Cn=new O({props:{data:["linl[0][0]","white"]}}),Tn=new O({props:{data:["...","white"]}}),Gn=new O({props:{data:["linl","white"]}}),_n=new O({props:{data:[["[...l, ...[","white"],["8, 10","blue"],["]","white"]]}}),{c(){$=e("div"),m=e("h2"),m.textContent=Jn,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),B=o("「数値型」「文字列型」とは別のデータ型として、「配列("),L(E.$$.fragment),D=o(")型」というものがあります。\n      "),S=e("br"),k=o("\n      配列は複数のデータを一つの変数にまとめて保存するためのもので、括弧"),L(y.$$.fragment),T=o("\n      とカンマ"),L(j.$$.fragment),A=o(" を使って定義します。\n      "),G=e("br"),M=o("\n      「リスト」とよばれることもあります。"),_=p(),q=e("hr"),z=p(),W=e("p"),U=o("配列に含まれるそれぞれのデータを「要素」とよび、要素は左から 0番, 1番, 2番, ... と番号がついています。\n      "),F=e("br"),J=o("\n      配列の要素を使うには、"),L(K.$$.fragment),Q=o(" のように配列名に括弧をつけて番号を指定します。\n      "),X=e("br"),Y=o("\n      また、"),L(Z.$$.fragment),nn=o(" のように書くことで、配列のなかにいくつ要素があるか確認することもできます。\n      "),en=e("br"),tn=o("\n      このプログラムを実行して、配列とその中の要素を表示できるか確認してみましょう。"),rn=p(),an=e("hr"),sn=p(),ln=e("div"),L($n.$$.fragment),fn=p(),cn=e("div"),mn=e("hr"),gn=p(),un=e("p"),un.textContent=Kn,pn=p(),hn=e("hr"),dn=p(),wn=e("p"),vn=o("少し複雑ですが、配列のなかに配列を入れることもできます。\n      "),bn=e("br"),xn=o("\n      変数"),L(Bn.$$.fragment),En=o(" は配列の中に 2つの配列が入っており、要素数は 2 です。\n      "),Rn=e("br"),Ln=p(),L(Pn.$$.fragment),Hn=o(" は配列の中の最初の要素で、\n      "),L(Cn.$$.fragment),In=o(" はその中の最初の要素です。"),Vn=p(),Dn=e("hr"),Sn=p(),kn=e("p"),yn=o("また、2つの配列から、それぞれの要素を含む1つの配列を作りたい場合は "),L(Tn.$$.fragment),Nn=o(" を使って配列を展開します。\n      "),jn=e("br"),An=o("\n      変数"),L(Gn.$$.fragment),Mn=o(" に代入する部分を\n      "),L(_n.$$.fragment),qn=o(" のように書き換えて実行してみましょう。\n      "),zn=e("br"),On=o("\n      結果はどう変わりましたか？"),Wn=p(),Un=e("hr"),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-gnbxn0"!==h(m)&&(m.textContent=Jn),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{});var l=r(x);B=f(l,"「数値型」「文字列型」とは別のデータ型として、「配列("),P(E.$$.fragment,l),D=f(l,")型」というものがあります。\n      "),S=t(l,"BR",{}),k=f(l,"\n      配列は複数のデータを一つの変数にまとめて保存するためのもので、括弧"),P(y.$$.fragment,l),T=f(l,"\n      とカンマ"),P(j.$$.fragment,l),A=f(l," を使って定義します。\n      "),G=t(l,"BR",{}),M=f(l,"\n      「リスト」とよばれることもあります。"),l.forEach(a),_=d(s),q=t(s,"HR",{class:!0}),z=d(s),W=t(s,"P",{});var o=r(W);U=f(o,"配列に含まれるそれぞれのデータを「要素」とよび、要素は左から 0番, 1番, 2番, ... と番号がついています。\n      "),F=t(o,"BR",{}),J=f(o,"\n      配列の要素を使うには、"),P(K.$$.fragment,o),Q=f(o," のように配列名に括弧をつけて番号を指定します。\n      "),X=t(o,"BR",{}),Y=f(o,"\n      また、"),P(Z.$$.fragment,o),nn=f(o," のように書くことで、配列のなかにいくつ要素があるか確認することもできます。\n      "),en=t(o,"BR",{}),tn=f(o,"\n      このプログラムを実行して、配列とその中の要素を表示できるか確認してみましょう。"),o.forEach(a),rn=d(s),an=t(s,"HR",{class:!0}),s.forEach(a),sn=d(e),ln=t(e,"DIV",{class:!0});var c=r(ln);P($n.$$.fragment,c),c.forEach(a),fn=d(e),cn=t(e,"DIV",{});var u=r(cn);mn=t(u,"HR",{class:!0}),gn=d(u),un=t(u,"P",{"data-svelte-h":!0}),"svelte-1t3p5ff"!==h(un)&&(un.textContent=Kn),pn=d(u),hn=t(u,"HR",{class:!0}),dn=d(u),wn=t(u,"P",{});var p=r(wn);vn=f(p,"少し複雑ですが、配列のなかに配列を入れることもできます。\n      "),bn=t(p,"BR",{}),xn=f(p,"\n      変数"),P(Bn.$$.fragment,p),En=f(p," は配列の中に 2つの配列が入っており、要素数は 2 です。\n      "),Rn=t(p,"BR",{}),Ln=d(p),P(Pn.$$.fragment,p),Hn=f(p," は配列の中の最初の要素で、\n      "),P(Cn.$$.fragment,p),In=f(p," はその中の最初の要素です。"),p.forEach(a),Vn=d(u),Dn=t(u,"HR",{class:!0}),Sn=d(u),kn=t(u,"P",{});var w=r(kn);yn=f(w,"また、2つの配列から、それぞれの要素を含む1つの配列を作りたい場合は "),P(Tn.$$.fragment,w),Nn=f(w," を使って配列を展開します。\n      "),jn=t(w,"BR",{}),An=f(w,"\n      変数"),P(Gn.$$.fragment,w),Mn=f(w," に代入する部分を\n      "),P(_n.$$.fragment,w),qn=f(w," のように書き換えて実行してみましょう。\n      "),zn=t(w,"BR",{}),On=f(w,"\n      結果はどう変わりましたか？"),w.forEach(a),Wn=d(u),Un=t(u,"HR",{class:!0}),u.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(q,"class","cBorderLine"),s(an,"class","cBorderLine"),s(ln,"class","cResponsiveCodeExecuter"),s(mn,"class","cBorderLine"),s(hn,"class","cBorderLine"),s(Dn,"class","cBorderLine"),s(Un,"class","cBorderLine"),s($,"class","max-w-[1000px]")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(x,B),H(E,x,null),c(x,D),c(x,S),c(x,k),H(y,x,null),c(x,T),H(j,x,null),c(x,A),c(x,G),c(x,M),c(i,_),c(i,q),c(i,z),c(i,W),c(W,U),c(W,F),c(W,J),H(K,W,null),c(W,Q),c(W,X),c(W,Y),H(Z,W,null),c(W,nn),c(W,en),c(W,tn),c(i,rn),c(i,an),c($,sn),c($,ln),H($n,ln,null),c($,fn),c($,cn),c(cn,mn),c(cn,gn),c(cn,un),c(cn,pn),c(cn,hn),c(cn,dn),c(cn,wn),c(wn,vn),c(wn,bn),c(wn,xn),H(Bn,wn,null),c(wn,En),c(wn,Rn),c(wn,Ln),H(Pn,wn,null),c(wn,Hn),H(Cn,wn,null),c(wn,In),c(cn,Vn),c(cn,Dn),c(cn,Sn),c(cn,kn),c(kn,yn),H(Tn,kn,null),c(kn,Nn),c(kn,jn),c(kn,An),H(Gn,kn,null),c(kn,Mn),H(_n,kn,null),c(kn,qn),c(kn,zn),c(kn,On),c(cn,Wn),c(cn,Un),Fn=!0},p(n,[e]){const t={};!on&&2&e&&(on=!0,t.codeExeProps=n[1],w((()=>on=!1))),$n.$set(t)},i(n){Fn||(C(E.$$.fragment,n),C(y.$$.fragment,n),C(j.$$.fragment,n),C(K.$$.fragment,n),C(Z.$$.fragment,n),C($n.$$.fragment,n),C(Bn.$$.fragment,n),C(Pn.$$.fragment,n),C(Cn.$$.fragment,n),C(Tn.$$.fragment,n),C(Gn.$$.fragment,n),C(_n.$$.fragment,n),Fn=!0)},o(n){I(E.$$.fragment,n),I(y.$$.fragment,n),I(j.$$.fragment,n),I(K.$$.fragment,n),I(Z.$$.fragment,n),I($n.$$.fragment,n),I(Bn.$$.fragment,n),I(Pn.$$.fragment,n),I(Cn.$$.fragment,n),I(Tn.$$.fragment,n),I(Gn.$$.fragment,n),I(_n.$$.fragment,n),Fn=!1},d(e){e&&a($),V(E),V(y),V(j),V(K),V(Z),n[3](null),V($n),V(Bn),V(Pn),V(Cn),V(Tn),V(Gn),V(_n)}}}function en(n,e,t){let r,a={code:'const l = [2, 4, 6];\nlog("list: " + l);\nlog("[0]: " + l[0]);\nlog("[1]+[2]: " + (l[1] + l[2]));\nlog("list len: " + l.length);\n\nconst linl = [l, [8, 10]]\nlog("linl[0]: " + linl[0]);\nlog("linl[0][0]: " + linl[0][0]);\nlog("linl[1][0]: " + linl[1][0]);\nlog("linl len: " + linl.length);\nreturn linl;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class tn extends B{constructor(e){super(),E(this,e,en,nn,n,{})}}function rn(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn,xn,Bn,En,Rn,Ln,Pn,Hn,Cn,In,Vn,Dn,Sn,kn,yn,Tn,Nn,jn,An,Gn,Mn,_n,qn,zn,On,Wn,Un,Fn,Jn,Kn,Qn,Xn,Yn,Zn,ne="プログラムの基礎 Lesson5 : 条件分岐";function ee(e){n[4](e)}E=new O({props:{data:["if","red"]}}),y=new O({props:{data:[["if","red"],[" ( ... )","white"]]}}),z=new O({props:{data:["num","white"]}}),J=new O({props:{data:["%","white"]}}),Q=new O({props:{data:[["num % ","white"],["2","blue"]]}}),Y=new O({props:{data:["num","white"]}}),nn=new O({props:{data:["2","blue"]}}),an=new O({props:{data:["0","blue"]}}),on=new O({props:{data:["num","white"]}});let te={allowedGlobals:n[2]};return void 0!==n[1]&&(te.codeExeProps=n[1]),pn=new N({props:te}),n[3](pn),u.push((()=>R(pn,"codeExeProps",ee))),Bn=new O({props:{data:["===","white"]}}),Pn=new O({props:{data:["true","blue"]}}),Cn=new O({props:{data:["false","blue"]}}),Vn=new O({props:{data:["Boolean","white"]}}),yn=new O({props:{data:[["if","red"],[" ( ... )","white"]]}}),Nn=new O({props:{data:["{ ... }","white"]}}),Mn=new O({props:{data:[["else ","red"],["{ ... }","white"]]}}),Fn=new O({props:{data:[["const ","red"],["num = ","white"],['"str"',"lightblue"]]}}),{c(){$=e("div"),m=e("h2"),m.textContent=ne,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),B=o("次に紹介する強力なアイテムは「条件分岐("),L(E.$$.fragment),D=o("分岐)」です。\n      "),S=e("br"),k=o("\n      条件分岐は、"),L(y.$$.fragment),T=o(" の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),j=e("br"),A=p(),G=e("hr"),M=p(),_=e("p"),q=o("このプログラムでは、変数"),L(z.$$.fragment),W=o(" が偶数か奇数かを判定しています。\n      "),U=e("br"),F=p(),L(J.$$.fragment),K=o(" は割り算の余りを求める演算子で、\n      "),L(Q.$$.fragment),X=o(" は\n      "),L(Y.$$.fragment),Z=o(" を\n      "),L(nn.$$.fragment),en=o(" で割った余りを求めます。\n      "),tn=e("br"),rn=o("\n      偶数の場合、割り切れるので余りは "),L(an.$$.fragment),sn=o(" になります。\n      "),ln=e("br"),$n=o("\n      実行して確かめてみましょう。 また、\n      "),L(on.$$.fragment),fn=o(" を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),cn=p(),mn=e("hr"),gn=p(),un=e("div"),L(pn.$$.fragment),dn=p(),wn=e("div"),vn=e("hr"),bn=p(),xn=e("p"),L(Bn.$$.fragment),En=o(" は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),Rn=e("br"),Ln=o("\n      真偽値とは、「真("),L(Pn.$$.fragment),Hn=o(")」または「偽("),L(Cn.$$.fragment),In=o(")」のどちらかを取る、「真偽型("),L(Vn.$$.fragment),Dn=o(")」の値です。\n      "),Sn=e("br"),kn=p(),L(yn.$$.fragment),Tn=o(" の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),L(Nn.$$.fragment),jn=o(" の中の処理が実行されます。\n      "),An=e("br"),Gn=p(),L(Mn.$$.fragment),_n=o(" の中の処理は、条件式が偽となる場合に実行されます。"),qn=p(),zn=e("hr"),On=p(),Wn=e("p"),Un=o("では、もし "),L(Fn.$$.fragment),Jn=o(" としたら結果はどうなるでしょう？\n      "),Kn=e("br"),Qn=o("\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),Xn=p(),Yn=e("hr"),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-1bsmh4a"!==h(m)&&(m.textContent=ne),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{});var l=r(x);B=f(l,"次に紹介する強力なアイテムは「条件分岐("),P(E.$$.fragment,l),D=f(l,"分岐)」です。\n      "),S=t(l,"BR",{}),k=f(l,"\n      条件分岐は、"),P(y.$$.fragment,l),T=f(l," の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),j=t(l,"BR",{}),l.forEach(a),A=d(s),G=t(s,"HR",{class:!0}),M=d(s),_=t(s,"P",{});var o=r(_);q=f(o,"このプログラムでは、変数"),P(z.$$.fragment,o),W=f(o," が偶数か奇数かを判定しています。\n      "),U=t(o,"BR",{}),F=d(o),P(J.$$.fragment,o),K=f(o," は割り算の余りを求める演算子で、\n      "),P(Q.$$.fragment,o),X=f(o," は\n      "),P(Y.$$.fragment,o),Z=f(o," を\n      "),P(nn.$$.fragment,o),en=f(o," で割った余りを求めます。\n      "),tn=t(o,"BR",{}),rn=f(o,"\n      偶数の場合、割り切れるので余りは "),P(an.$$.fragment,o),sn=f(o," になります。\n      "),ln=t(o,"BR",{}),$n=f(o,"\n      実行して確かめてみましょう。 また、\n      "),P(on.$$.fragment,o),fn=f(o," を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),o.forEach(a),cn=d(s),mn=t(s,"HR",{class:!0}),s.forEach(a),gn=d(e),un=t(e,"DIV",{class:!0});var c=r(un);P(pn.$$.fragment,c),c.forEach(a),dn=d(e),wn=t(e,"DIV",{});var u=r(wn);vn=t(u,"HR",{class:!0}),bn=d(u),xn=t(u,"P",{});var p=r(xn);P(Bn.$$.fragment,p),En=f(p," は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),Rn=t(p,"BR",{}),Ln=f(p,"\n      真偽値とは、「真("),P(Pn.$$.fragment,p),Hn=f(p,")」または「偽("),P(Cn.$$.fragment,p),In=f(p,")」のどちらかを取る、「真偽型("),P(Vn.$$.fragment,p),Dn=f(p,")」の値です。\n      "),Sn=t(p,"BR",{}),kn=d(p),P(yn.$$.fragment,p),Tn=f(p," の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),P(Nn.$$.fragment,p),jn=f(p," の中の処理が実行されます。\n      "),An=t(p,"BR",{}),Gn=d(p),P(Mn.$$.fragment,p),_n=f(p," の中の処理は、条件式が偽となる場合に実行されます。"),p.forEach(a),qn=d(u),zn=t(u,"HR",{class:!0}),On=d(u),Wn=t(u,"P",{});var w=r(Wn);Un=f(w,"では、もし "),P(Fn.$$.fragment,w),Jn=f(w," としたら結果はどうなるでしょう？\n      "),Kn=t(w,"BR",{}),Qn=f(w,"\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),w.forEach(a),Xn=d(u),Yn=t(u,"HR",{class:!0}),u.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(G,"class","cBorderLine"),s(mn,"class","cBorderLine"),s(un,"class","cResponsiveCodeExecuter"),s(vn,"class","cBorderLine"),s(zn,"class","cBorderLine"),s(Yn,"class","cBorderLine"),s($,"class","max-w-[1000px]")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(x,B),H(E,x,null),c(x,D),c(x,S),c(x,k),H(y,x,null),c(x,T),c(x,j),c(i,A),c(i,G),c(i,M),c(i,_),c(_,q),H(z,_,null),c(_,W),c(_,U),c(_,F),H(J,_,null),c(_,K),H(Q,_,null),c(_,X),H(Y,_,null),c(_,Z),H(nn,_,null),c(_,en),c(_,tn),c(_,rn),H(an,_,null),c(_,sn),c(_,ln),c(_,$n),H(on,_,null),c(_,fn),c(i,cn),c(i,mn),c($,gn),c($,un),H(pn,un,null),c($,dn),c($,wn),c(wn,vn),c(wn,bn),c(wn,xn),H(Bn,xn,null),c(xn,En),c(xn,Rn),c(xn,Ln),H(Pn,xn,null),c(xn,Hn),H(Cn,xn,null),c(xn,In),H(Vn,xn,null),c(xn,Dn),c(xn,Sn),c(xn,kn),H(yn,xn,null),c(xn,Tn),H(Nn,xn,null),c(xn,jn),c(xn,An),c(xn,Gn),H(Mn,xn,null),c(xn,_n),c(wn,qn),c(wn,zn),c(wn,On),c(wn,Wn),c(Wn,Un),H(Fn,Wn,null),c(Wn,Jn),c(Wn,Kn),c(Wn,Qn),c(wn,Xn),c(wn,Yn),Zn=!0},p(n,[e]){const t={};!hn&&2&e&&(hn=!0,t.codeExeProps=n[1],w((()=>hn=!1))),pn.$set(t)},i(n){Zn||(C(E.$$.fragment,n),C(y.$$.fragment,n),C(z.$$.fragment,n),C(J.$$.fragment,n),C(Q.$$.fragment,n),C(Y.$$.fragment,n),C(nn.$$.fragment,n),C(an.$$.fragment,n),C(on.$$.fragment,n),C(pn.$$.fragment,n),C(Bn.$$.fragment,n),C(Pn.$$.fragment,n),C(Cn.$$.fragment,n),C(Vn.$$.fragment,n),C(yn.$$.fragment,n),C(Nn.$$.fragment,n),C(Mn.$$.fragment,n),C(Fn.$$.fragment,n),Zn=!0)},o(n){I(E.$$.fragment,n),I(y.$$.fragment,n),I(z.$$.fragment,n),I(J.$$.fragment,n),I(Q.$$.fragment,n),I(Y.$$.fragment,n),I(nn.$$.fragment,n),I(an.$$.fragment,n),I(on.$$.fragment,n),I(pn.$$.fragment,n),I(Bn.$$.fragment,n),I(Pn.$$.fragment,n),I(Cn.$$.fragment,n),I(Vn.$$.fragment,n),I(yn.$$.fragment,n),I(Nn.$$.fragment,n),I(Mn.$$.fragment,n),I(Fn.$$.fragment,n),Zn=!1},d(e){e&&a($),V(E),V(y),V(z),V(J),V(Q),V(Y),V(nn),V(an),V(on),n[3](null),V(pn),V(Bn),V(Pn),V(Cn),V(Vn),V(yn),V(Nn),V(Mn),V(Fn)}}}function an(n,e,t){let r,a={code:'const num = 10;\nlet result;\nif (num % 2 === 0) {\n  result = num + " is Even.";\n} else {\n  result = num + " is Odd.";\n}\nreturn result;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class sn extends B{constructor(e){super(),E(this,e,an,rn,n,{})}}function ln(n){let $,m,g,i,v,b,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn,xn,Bn,En="プログラムの基礎 Lesson6 : 繰り返し(ループ)",Rn='<hr class="cBorderLine"/> <p>初めに「同じ処理を繰り返す」と書きましたが、実際はこのプログラムのように変数を使って、\n      <br/>\n      少しだけ異なる処理を複数回実行したいときに使うこともできます。\n      <br/>\n      条件式やループ内の処理を書き換えて、繰り返しの回数や内容を変えてみましょう。思ったとおりに動きましたか？</p> <hr class="cBorderLine"/>';function Ln(e){n[4](e)}E=new O({props:{data:["for","red"]}}),y=new O({props:{data:[["for","red"],[" ( ... )","white"]]}}),W=new O({props:{data:[["let ","red"],["i = ","white"],["1","lightblue"],[";","white"]]}}),F=new O({props:{data:["i","white"]}}),K=new O({props:{data:["1","blue"]}}),Z=new O({props:{data:[["i <= ","white"],["10","lightblue"],[";","white"]]}}),en=new O({props:{data:["i","white"]}}),rn=new O({props:{data:["10","blue"]}}),$n=new O({props:{data:[["i++;","white"]]}}),fn=new O({props:{data:["i","white"]}});let Pn={allowedGlobals:n[2]};return void 0!==n[1]&&(Pn.codeExeProps=n[1]),wn=new N({props:Pn}),n[3](wn),u.push((()=>R(wn,"codeExeProps",Ln))),{c(){$=e("div"),m=e("h2"),m.textContent=En,g=p(),i=e("div"),v=e("hr"),b=p(),x=e("p"),B=o("最後に紹介する強力なアイテムは「繰り返し("),L(E.$$.fragment),D=o("ループ)」です。\n      "),S=e("br"),k=o("\n      繰り返しは、"),L(y.$$.fragment),T=o(" の括弧で囲まれた式に従い、同じ処理を繰り返し行うことができます。"),j=p(),A=e("hr"),G=p(),M=e("p"),_=o("このプログラムでは、1 から 10 までの数値を配列に格納しています。\n      "),q=e("br"),z=o("\n      括弧の中の初めの条件式 "),L(W.$$.fragment),U=o(" は、変数"),L(F.$$.fragment),J=o(" が "),L(K.$$.fragment),Q=o(" からスタートすることを示しています。\n      "),X=e("br"),Y=o("\n      次の条件式 "),L(Z.$$.fragment),nn=o(" は、変数"),L(en.$$.fragment),tn=o(" が "),L(rn.$$.fragment),an=o(" 以下である限り、繰り返し処理を続けることを示しています。\n      "),sn=e("br"),ln=o("\n      最後の条件式 "),L($n.$$.fragment),on=o(" は、ループ毎に変数"),L(fn.$$.fragment),cn=o(" の値を 1\n      ずつ増やすことを示しています。\n      "),mn=e("br"),gn=o("\n      実行して、ループがどのように動くか見てみましょう。"),un=p(),pn=e("hr"),hn=p(),dn=e("div"),L(wn.$$.fragment),bn=p(),xn=e("div"),xn.innerHTML=Rn,this.h()},l(n){$=t(n,"DIV",{});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-o441um"!==h(m)&&(m.textContent=En),g=d(e),i=t(e,"DIV",{});var s=r(i);v=t(s,"HR",{class:!0}),b=d(s),x=t(s,"P",{});var l=r(x);B=f(l,"最後に紹介する強力なアイテムは「繰り返し("),P(E.$$.fragment,l),D=f(l,"ループ)」です。\n      "),S=t(l,"BR",{}),k=f(l,"\n      繰り返しは、"),P(y.$$.fragment,l),T=f(l," の括弧で囲まれた式に従い、同じ処理を繰り返し行うことができます。"),l.forEach(a),j=d(s),A=t(s,"HR",{class:!0}),G=d(s),M=t(s,"P",{});var o=r(M);_=f(o,"このプログラムでは、1 から 10 までの数値を配列に格納しています。\n      "),q=t(o,"BR",{}),z=f(o,"\n      括弧の中の初めの条件式 "),P(W.$$.fragment,o),U=f(o," は、変数"),P(F.$$.fragment,o),J=f(o," が "),P(K.$$.fragment,o),Q=f(o," からスタートすることを示しています。\n      "),X=t(o,"BR",{}),Y=f(o,"\n      次の条件式 "),P(Z.$$.fragment,o),nn=f(o," は、変数"),P(en.$$.fragment,o),tn=f(o," が "),P(rn.$$.fragment,o),an=f(o," 以下である限り、繰り返し処理を続けることを示しています。\n      "),sn=t(o,"BR",{}),ln=f(o,"\n      最後の条件式 "),P($n.$$.fragment,o),on=f(o," は、ループ毎に変数"),P(fn.$$.fragment,o),cn=f(o," の値を 1\n      ずつ増やすことを示しています。\n      "),mn=t(o,"BR",{}),gn=f(o,"\n      実行して、ループがどのように動くか見てみましょう。"),o.forEach(a),un=d(s),pn=t(s,"HR",{class:!0}),s.forEach(a),hn=d(e),dn=t(e,"DIV",{class:!0});var c=r(dn);P(wn.$$.fragment,c),c.forEach(a),bn=d(e),xn=t(e,"DIV",{"data-svelte-h":!0}),"svelte-11a71kw"!==h(xn)&&(xn.innerHTML=Rn),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(v,"class","cBorderLine"),s(A,"class","cBorderLine"),s(pn,"class","cBorderLine"),s(dn,"class","cResponsiveCodeExecuter")},m(n,e){l(n,$,e),c($,m),c($,g),c($,i),c(i,v),c(i,b),c(i,x),c(x,B),H(E,x,null),c(x,D),c(x,S),c(x,k),H(y,x,null),c(x,T),c(i,j),c(i,A),c(i,G),c(i,M),c(M,_),c(M,q),c(M,z),H(W,M,null),c(M,U),H(F,M,null),c(M,J),H(K,M,null),c(M,Q),c(M,X),c(M,Y),H(Z,M,null),c(M,nn),H(en,M,null),c(M,tn),H(rn,M,null),c(M,an),c(M,sn),c(M,ln),H($n,M,null),c(M,on),H(fn,M,null),c(M,cn),c(M,mn),c(M,gn),c(i,un),c(i,pn),c($,hn),c($,dn),H(wn,dn,null),c($,bn),c($,xn),Bn=!0},p(n,[e]){const t={};!vn&&2&e&&(vn=!0,t.codeExeProps=n[1],w((()=>vn=!1))),wn.$set(t)},i(n){Bn||(C(E.$$.fragment,n),C(y.$$.fragment,n),C(W.$$.fragment,n),C(F.$$.fragment,n),C(K.$$.fragment,n),C(Z.$$.fragment,n),C(en.$$.fragment,n),C(rn.$$.fragment,n),C($n.$$.fragment,n),C(fn.$$.fragment,n),C(wn.$$.fragment,n),Bn=!0)},o(n){I(E.$$.fragment,n),I(y.$$.fragment,n),I(W.$$.fragment,n),I(F.$$.fragment,n),I(K.$$.fragment,n),I(Z.$$.fragment,n),I(en.$$.fragment,n),I(rn.$$.fragment,n),I($n.$$.fragment,n),I(fn.$$.fragment,n),I(wn.$$.fragment,n),Bn=!1},d(e){e&&a($),V(E),V(y),V(W),V(F),V(K),V(Z),V(en),V(rn),V($n),V(fn),n[3](null),V(wn)}}}function $n(n,e,t){let r,a={code:'let list = [];\nfor (let i = 1; i <= 10; i++) {\n  log("loop: i = " + i);\n  list = [...list, i];\n}\n\nreturn list;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)}]}class on extends B{constructor(e){super(),E(this,e,$n,ln,n,{})}}function fn(n){let $,m,g,i,x,B,E,D,S,k,y,T,j,A,G,M,_,q,z,W,U,F,J,K,Q,X,Y,Z,nn,en,tn,rn,an,sn,ln,$n,on,fn,cn,mn,gn,un,pn,hn,dn,wn,vn,bn="プログラムの基礎 Lesson7 : ループ と 条件分岐 の組み合わせ",xn="ループと条件分岐を組み合わせることで、より複雑な処理を行うことができます。",Bn='<span class="cLinkButtonStyle">Test Code Executer</span> ';function En(e){n[4](e)}G=new O({props:{data:[["for ","red"],["(","white"],["let ","red"],["num ","white"],["of ","red"],["nums)","white"]]}}),z=new O({props:{data:[["if ","red"],["(num % ","white"],["2","blue"],[" !== ","white"],["0","blue"],[")","white"]]}}),J=new O({props:{data:["!==","white"]}});let Rn={allowedGlobals:n[2]};return void 0!==n[1]&&(Rn.codeExeProps=n[1]),tn=new N({props:Rn}),n[3](tn),u.push((()=>R(tn,"codeExeProps",En))),{c(){$=e("div"),m=e("h2"),m.textContent=bn,g=p(),i=e("div"),x=e("hr"),B=p(),E=e("p"),E.textContent=xn,D=p(),S=e("hr"),k=p(),y=e("p"),T=o("このプログラムでは、1 から 6 までの数値の中から、奇数だけを取り出しています。\n      "),j=e("br"),A=o("\n      ループの条件式を "),L(G.$$.fragment),M=o(" のように書くと、配列の要素を 1つずつ取り出して処理することができます。\n      "),_=e("br"),q=o("\n      ループ処理を 6回繰り返し、それぞれの数値を "),L(z.$$.fragment),W=o(" で奇数か偶数か判定しています。\n      "),U=e("br"),F=o("\n      なお、 "),L(J.$$.fragment),K=o(" は等しくない場合に「真」を返す演算子です。\n      "),Q=e("br"),X=o("\n      この例では、2で割り切れない場合に「真」となるため、奇数の場合のみ分岐内の処理を実行します。"),Y=p(),Z=e("hr"),nn=p(),en=e("div"),L(tn.$$.fragment),an=p(),sn=e("div"),ln=e("hr"),$n=p(),on=e("p"),fn=o("ここまでで、プログラミングの基礎的な概念を学びました。\n      "),cn=e("br"),mn=o("\n      「"),gn=e("button"),gn.innerHTML=Bn,un=o("」は自由にプログラムを書いて実行できる環境です。試してみましょう！"),pn=p(),hn=e("hr"),this.h()},l(n){$=t(n,"DIV",{});var e=r($);m=t(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-1gxe1bh"!==h(m)&&(m.textContent=bn),g=d(e),i=t(e,"DIV",{});var s=r(i);x=t(s,"HR",{class:!0}),B=d(s),E=t(s,"P",{"data-svelte-h":!0}),"svelte-5kqloq"!==h(E)&&(E.textContent=xn),D=d(s),S=t(s,"HR",{class:!0}),k=d(s),y=t(s,"P",{});var l=r(y);T=f(l,"このプログラムでは、1 から 6 までの数値の中から、奇数だけを取り出しています。\n      "),j=t(l,"BR",{}),A=f(l,"\n      ループの条件式を "),P(G.$$.fragment,l),M=f(l," のように書くと、配列の要素を 1つずつ取り出して処理することができます。\n      "),_=t(l,"BR",{}),q=f(l,"\n      ループ処理を 6回繰り返し、それぞれの数値を "),P(z.$$.fragment,l),W=f(l," で奇数か偶数か判定しています。\n      "),U=t(l,"BR",{}),F=f(l,"\n      なお、 "),P(J.$$.fragment,l),K=f(l," は等しくない場合に「真」を返す演算子です。\n      "),Q=t(l,"BR",{}),X=f(l,"\n      この例では、2で割り切れない場合に「真」となるため、奇数の場合のみ分岐内の処理を実行します。"),l.forEach(a),Y=d(s),Z=t(s,"HR",{class:!0}),s.forEach(a),nn=d(e),en=t(e,"DIV",{class:!0});var o=r(en);P(tn.$$.fragment,o),o.forEach(a),an=d(e),sn=t(e,"DIV",{});var c=r(sn);ln=t(c,"HR",{class:!0}),$n=d(c),on=t(c,"P",{});var u=r(on);fn=f(u,"ここまでで、プログラミングの基礎的な概念を学びました。\n      "),cn=t(u,"BR",{}),mn=f(u,"\n      「"),gn=t(u,"BUTTON",{"data-svelte-h":!0}),"svelte-1a7flya"!==h(gn)&&(gn.innerHTML=Bn),un=f(u,"」は自由にプログラムを書いて実行できる環境です。試してみましょう！"),u.forEach(a),pn=d(c),hn=t(c,"HR",{class:!0}),c.forEach(a),e.forEach(a),this.h()},h(){s(m,"class","cBookTitle"),s(x,"class","cBorderLine"),s(S,"class","cBorderLine"),s(Z,"class","cBorderLine"),s(en,"class","cResponsiveCodeExecuter"),s(ln,"class","cBorderLine"),s(hn,"class","cBorderLine")},m(e,t){l(e,$,t),c($,m),c($,g),c($,i),c(i,x),c(i,B),c(i,E),c(i,D),c(i,S),c(i,k),c(i,y),c(y,T),c(y,j),c(y,A),H(G,y,null),c(y,M),c(y,_),c(y,q),H(z,y,null),c(y,W),c(y,U),c(y,F),H(J,y,null),c(y,K),c(y,Q),c(y,X),c(i,Y),c(i,Z),c($,nn),c($,en),H(tn,en,null),c($,an),c($,sn),c(sn,ln),c(sn,$n),c(sn,on),c(on,fn),c(on,cn),c(on,mn),c(on,gn),c(on,un),c(sn,pn),c(sn,hn),dn=!0,wn||(vn=v(gn,"click",b(n[5])),wn=!0)},p(n,[e]){const t={};!rn&&2&e&&(rn=!0,t.codeExeProps=n[1],w((()=>rn=!1))),tn.$set(t)},i(n){dn||(C(G.$$.fragment,n),C(z.$$.fragment,n),C(J.$$.fragment,n),C(tn.$$.fragment,n),dn=!0)},o(n){I(G.$$.fragment,n),I(z.$$.fragment,n),I(J.$$.fragment,n),I(tn.$$.fragment,n),dn=!1},d(e){e&&a($),V(G),V(z),V(J),n[3](null),V(tn),wn=!1,vn()}}}function cn(n,e,t){let r,a={code:'const nums = [1, 2, 3, 4, 5, 6];\nlet oddNums = [];\nfor (let num of nums) {\n  log("loop: num = " + num);\n  if (num % 2 !== 0) {\n    oddNums = [...oddNums, num];\n  }\n}\n\nreturn oddNums;',resultString:"",logs:[]};return[r,a,{},function(n){u[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){a=n,t(1,a)},()=>j("/executer")]}class mn extends B{constructor(e){super(),E(this,e,cn,fn,n,{})}}function gn(n,e,t){const r=n.slice();return r[3]=e[t].index,r[7]=e[t].name,r[8]=e[t].label,r}function un(n,e,t){const r=n.slice();return r[3]=e[t].index,r[4]=e[t].component,r}function pn(n){let $,m,g,i,u=n[8]+"";return{c(){$=e("span"),m=o(u),i=p(),this.h()},l(n){$=t(n,"SPAN",{class:!0});var e=r($);m=f(e,u),e.forEach(a),i=d(n),this.h()},h(){s($,"class",g="font-pixel10 "+(n[0]===n[3]?"font-bold":""))},m(n,e){l(n,$,e),c($,m),l(n,i,e)},p(n,e){1&e&&g!==(g="font-pixel10 "+(n[0]===n[3]?"font-bold":""))&&s($,"class",g)},d(n){n&&(a($),a(i))}}}function hn(n){let e,t,r;function a(e){n[2](e)}let s={name:n[7],value:n[3],$$slots:{default:[pn]},$$scope:{ctx:n}};return void 0!==n[0]&&(s.group=n[0]),e=new T({props:s}),u.push((()=>R(e,"group",a))),{c(){L(e.$$.fragment)},l(n){P(e.$$.fragment,n)},m(n,t){H(e,n,t),r=!0},p(n,r){const a={};2049&r&&(a.$$scope={dirty:r,ctx:n}),!t&&1&r&&(t=!0,a.group=n[0],w((()=>t=!1))),e.$set(a)},i(n){r||(C(e.$$.fragment,n),r=!0)},o(n){I(e.$$.fragment,n),r=!1},d(n){V(e,n)}}}function dn(n){let e,t,r=k(n[1]),s=[];for(let a=0;a<r.length;a+=1)s[a]=hn(gn(n,r,a));const $=n=>I(s[n],1,1,(()=>{s[n]=null}));return{c(){for(let n=0;n<s.length;n+=1)s[n].c();e=g()},l(n){for(let e=0;e<s.length;e+=1)s[e].l(n);e=g()},m(n,r){for(let e=0;e<s.length;e+=1)s[e]&&s[e].m(n,r);l(n,e,r),t=!0},p(n,t){if(3&t){let a;for(r=k(n[1]),a=0;a<r.length;a+=1){const l=gn(n,r,a);s[a]?(s[a].p(l,t),C(s[a],1)):(s[a]=hn(l),s[a].c(),C(s[a],1),s[a].m(e.parentNode,e))}for(D(),a=r.length;a<s.length;a+=1)$(a);S()}},i(n){if(!t){for(let n=0;n<r.length;n+=1)C(s[n]);t=!0}},o(n){s=s.filter(Boolean);for(let e=0;e<s.length;e+=1)I(s[e]);t=!1},d(n){n&&a(e),i(s,n)}}}function wn(n){let e,t,r;var s=n[4];return s&&(e=x(s,{})),{c(){e&&L(e.$$.fragment),t=g()},l(n){e&&P(e.$$.fragment,n),t=g()},m(n,a){e&&H(e,n,a),l(n,t,a),r=!0},p(n,r){if(s!==(s=n[4])){if(e){D();const n=e;I(n.$$.fragment,1,0,(()=>{V(n,1)})),S()}s?(e=x(s,{}),L(e.$$.fragment),C(e.$$.fragment,1),H(e,t.parentNode,t)):e=null}},i(n){r||(e&&C(e.$$.fragment,n),r=!0)},o(n){e&&I(e.$$.fragment,n),r=!1},d(n){n&&a(t),e&&V(e,n)}}}function vn(n){let e,t,r=n[0]===n[3]&&wn(n);return{c(){r&&r.c(),e=g()},l(n){r&&r.l(n),e=g()},m(n,a){r&&r.m(n,a),l(n,e,a),t=!0},p(n,t){n[0]===n[3]?r?(r.p(n,t),1&t&&C(r,1)):(r=wn(n),r.c(),C(r,1),r.m(e.parentNode,e)):r&&(D(),I(r,1,1,(()=>{r=null})),S())},i(n){t||(C(r),t=!0)},o(n){I(r),t=!1},d(n){n&&a(e),r&&r.d(n)}}}function bn(n){let $,o,f=k(n[1]),c=[];for(let e=0;e<f.length;e+=1)c[e]=vn(un(n,f,e));const m=n=>I(c[n],1,1,(()=>{c[n]=null}));return{c(){$=e("div");for(let n=0;n<c.length;n+=1)c[n].c();this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);for(let t=0;t<c.length;t+=1)c[t].l(e);e.forEach(a),this.h()},h(){s($,"class","flex flex-row w-full justify-center items-center gap-4 m-4")},m(n,e){l(n,$,e);for(let t=0;t<c.length;t+=1)c[t]&&c[t].m($,null);o=!0},p(n,e){if(3&e){let t;for(f=k(n[1]),t=0;t<f.length;t+=1){const r=un(n,f,t);c[t]?(c[t].p(r,e),C(c[t],1)):(c[t]=vn(r),c[t].c(),C(c[t],1),c[t].m($,null))}for(D(),t=f.length;t<c.length;t+=1)m(t);S()}},i(n){if(!o){for(let n=0;n<f.length;n+=1)C(c[n]);o=!0}},o(n){c=c.filter(Boolean);for(let e=0;e<c.length;e+=1)I(c[e]);o=!1},d(n){n&&a($),i(c,n)}}}function xn(n){let $,o,f,m;return f=new y({props:{$$slots:{panel:[bn],default:[dn]},$$scope:{ctx:n}}}),{c(){$=e("div"),o=e("div"),L(f.$$.fragment),this.h()},l(n){$=t(n,"DIV",{class:!0});var e=r($);o=t(e,"DIV",{class:!0});var s=r(o);P(f.$$.fragment,s),s.forEach(a),e.forEach(a),this.h()},h(){s(o,"class","flex justefy-center w-11/12"),s($,"class","cRouteBodyStyle")},m(n,e){l(n,$,e),c($,o),H(f,o,null),m=!0},p(n,[e]){const t={};2049&e&&(t.$$scope={dirty:e,ctx:n}),f.$set(t)},i(n){m||(C(f.$$.fragment,n),m=!0)},o(n){I(f.$$.fragment,n),m=!1},d(n){n&&a($),V(f)}}}function Bn(n,e,t){let r=1;return[r,[{index:1,name:"lesson1",label:"(Lesson 1)",component:F},{index:2,name:"lesson2",label:"(Lesson 2)",component:Q},{index:3,name:"lesson3",label:"(Lesson 3)",component:Z},{index:4,name:"lesson4",label:"(Lesson 4)",component:tn},{index:5,name:"lesson5",label:"(Lesson 5)",component:sn},{index:6,name:"lesson6",label:"(Lesson 6)",component:on},{index:7,name:"lesson7",label:"(Lesson 7)",component:mn}],function(n){r=n,t(0,r)}]}class En extends B{constructor(e){super(),E(this,e,Bn,xn,n,{})}}export{En as component};
