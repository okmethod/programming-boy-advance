import{s as n,p as e,e as a,a as r,t,c as $,b as s,m as f,f as l,d as m,g as o,h as g,i as c,j as u,q as p}from"../chunks/scheduler.CSycGpb7.js";import{S as d,i,f as h,b as w,d as b,m as v,t as B,a as R,e as E}from"../chunks/index.Bvdk1IJ9.js";import{C as x}from"../chunks/CodeSpan.Defe0fl-.js";import{C}from"../chunks/CodeExecuter.D1s7Y7zg.js";function H(n){let d,i,H,L,P,j,k,D,I,V,S,q,G,O,T,y,z,A,F,J,K,M,N,Q,U,W,X,Y,Z,_,nn,en,an,rn,tn,$n,sn,fn,ln,mn,on,gn,cn,un,pn,dn,hn,wn,bn,vn,Bn,Rn,En,xn,Cn,Hn,Ln,Pn,jn,kn,Dn,In,Vn,Sn,qn,Gn,On,Tn,yn,zn,An,Fn,Jn,Kn,Mn,Nn,Qn,Un,Wn,Xn,Yn,Zn,_n,ne="条件分岐";function ee(e){n[4](e)}I=new x({props:{data:["if","red"]}}),G=new x({props:{data:[["if","red"],[" ( ... )","white"]]}}),K=new x({props:{data:["num","white"]}}),U=new x({props:{data:["%","white"]}}),X=new x({props:{data:[["num % ","white"],["2","blue"]]}}),Z=new x({props:{data:["num","white"]}}),nn=new x({props:{data:["2","blue"]}}),tn=new x({props:{data:["0","blue"]}}),ln=new x({props:{data:["num","white"]}});let ae={allowedGlobals:n[2]};return void 0!==n[1]&&(ae.codeExeProps=n[1]),pn=new C({props:ae}),n[3](pn),e.push((()=>h(pn,"codeExeProps",ee))),Rn=new x({props:{data:["===","white"]}}),Hn=new x({props:{data:["true","blue"]}}),Pn=new x({props:{data:["false","blue"]}}),kn=new x({props:{data:["Boolean","white"]}}),Sn=new x({props:{data:[["if","red"],[" ( ... )","white"]]}}),Gn=new x({props:{data:["{ ... }","white"]}}),zn=new x({props:{data:[["else ","red"],["{ ... }","white"]]}}),Qn=new x({props:{data:[["const ","red"],["num = ","white"],['"str"',"lightblue"]]}}),{c(){d=a("div"),i=a("h2"),i.textContent=ne,H=r(),L=a("div"),P=a("hr"),j=r(),k=a("p"),D=t("次に紹介する強力なアイテムは「条件分岐("),w(I.$$.fragment),V=t("分岐)」です。\n      "),S=a("br"),q=t("\n      条件分岐は、"),w(G.$$.fragment),O=t(" の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),T=a("br"),y=r(),z=a("hr"),A=r(),F=a("p"),J=t("このプログラムでは、変数"),w(K.$$.fragment),M=t(" が偶数か奇数かを判定しています。\n      "),N=a("br"),Q=r(),w(U.$$.fragment),W=t(" は割り算の余りを求める演算子で、\n      "),w(X.$$.fragment),Y=t(" は\n      "),w(Z.$$.fragment),_=t(" を\n      "),w(nn.$$.fragment),en=t(" で割った余りを求めます。\n      "),an=a("br"),rn=t("\n      偶数の場合、割り切れるので余りは "),w(tn.$$.fragment),$n=t(" になります。\n      "),sn=a("br"),fn=t("\n      実行して確かめてみましょう。 また、\n      "),w(ln.$$.fragment),mn=t(" を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),on=r(),gn=a("hr"),cn=r(),un=a("div"),w(pn.$$.fragment),hn=r(),wn=a("div"),bn=a("hr"),vn=r(),Bn=a("p"),w(Rn.$$.fragment),En=t(" は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),xn=a("br"),Cn=t("\n      真偽値とは、「真("),w(Hn.$$.fragment),Ln=t(")」または「偽("),w(Pn.$$.fragment),jn=t(")」のどちらかを取る、「真偽型("),w(kn.$$.fragment),Dn=t(")」の値です。\n      "),In=a("br"),Vn=r(),w(Sn.$$.fragment),qn=t(" の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),w(Gn.$$.fragment),On=t(" の中の処理が実行されます。\n      "),Tn=a("br"),yn=r(),w(zn.$$.fragment),An=t(" の中の処理は、条件式が偽となる場合に実行されます。"),Fn=r(),Jn=a("hr"),Kn=r(),Mn=a("p"),Nn=t("では、もし "),w(Qn.$$.fragment),Un=t(" としたら結果はどうなるでしょう？\n      "),Wn=a("br"),Xn=t("\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),Yn=r(),Zn=a("hr"),this.h()},l(n){d=$(n,"DIV",{class:!0});var e=s(d);i=$(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-1rh1fwt"!==f(i)&&(i.textContent=ne),H=l(e),L=$(e,"DIV",{class:!0});var a=s(L);P=$(a,"HR",{class:!0}),j=l(a),k=$(a,"P",{});var r=s(k);D=m(r,"次に紹介する強力なアイテムは「条件分岐("),b(I.$$.fragment,r),V=m(r,"分岐)」です。\n      "),S=$(r,"BR",{}),q=m(r,"\n      条件分岐は、"),b(G.$$.fragment,r),O=m(r," の括弧で囲まれた式の条件が成り立つ場合と、成り立たない場合で別の処理をすることができます。\n      "),T=$(r,"BR",{}),r.forEach(o),y=l(a),z=$(a,"HR",{class:!0}),A=l(a),F=$(a,"P",{});var t=s(F);J=m(t,"このプログラムでは、変数"),b(K.$$.fragment,t),M=m(t," が偶数か奇数かを判定しています。\n      "),N=$(t,"BR",{}),Q=l(t),b(U.$$.fragment,t),W=m(t," は割り算の余りを求める演算子で、\n      "),b(X.$$.fragment,t),Y=m(t," は\n      "),b(Z.$$.fragment,t),_=m(t," を\n      "),b(nn.$$.fragment,t),en=m(t," で割った余りを求めます。\n      "),an=$(t,"BR",{}),rn=m(t,"\n      偶数の場合、割り切れるので余りは "),b(tn.$$.fragment,t),$n=m(t," になります。\n      "),sn=$(t,"BR",{}),fn=m(t,"\n      実行して確かめてみましょう。 また、\n      "),b(ln.$$.fragment,t),mn=m(t," を別の数値に変更して、正しく判定できるかどうか試してみましょう。"),t.forEach(o),on=l(a),gn=$(a,"HR",{class:!0}),a.forEach(o),cn=l(e),un=$(e,"DIV",{class:!0});var g=s(un);b(pn.$$.fragment,g),g.forEach(o),hn=l(e),wn=$(e,"DIV",{class:!0});var c=s(wn);bn=$(c,"HR",{class:!0}),vn=l(c),Bn=$(c,"P",{});var u=s(Bn);b(Rn.$$.fragment,u),En=m(u," は等しいかどうかを判定する演算子で、「真偽値」を返します。\n      "),xn=$(u,"BR",{}),Cn=m(u,"\n      真偽値とは、「真("),b(Hn.$$.fragment,u),Ln=m(u,")」または「偽("),b(Pn.$$.fragment,u),jn=m(u,")」のどちらかを取る、「真偽型("),b(kn.$$.fragment,u),Dn=m(u,")」の値です。\n      "),In=$(u,"BR",{}),Vn=l(u),b(Sn.$$.fragment,u),qn=m(u," の括弧で囲まれた部分の条件式が真となる場合に、続く\n      "),b(Gn.$$.fragment,u),On=m(u," の中の処理が実行されます。\n      "),Tn=$(u,"BR",{}),yn=l(u),b(zn.$$.fragment,u),An=m(u," の中の処理は、条件式が偽となる場合に実行されます。"),u.forEach(o),Fn=l(c),Jn=$(c,"HR",{class:!0}),Kn=l(c),Mn=$(c,"P",{});var p=s(Mn);Nn=m(p,"では、もし "),b(Qn.$$.fragment,p),Un=m(p," としたら結果はどうなるでしょう？\n      "),Wn=$(p,"BR",{}),Xn=m(p,"\n      文字列は、偶数でも奇数でもないはずですよね。なぜこの結果になるのか考えてみましょう。"),p.forEach(o),Yn=l(c),Zn=$(c,"HR",{class:!0}),c.forEach(o),e.forEach(o),this.h()},h(){g(i,"class","cLessonTitle"),g(P,"class","cBorderLine"),g(z,"class","cBorderLine"),g(gn,"class","cBorderLine"),g(L,"class","w-full"),g(un,"class","cResponsiveCodeExecuter"),g(bn,"class","cBorderLine"),g(Jn,"class","cBorderLine"),g(Zn,"class","cBorderLine"),g(wn,"class","w-full"),g(d,"class","cBookContents")},m(n,e){c(n,d,e),u(d,i),u(d,H),u(d,L),u(L,P),u(L,j),u(L,k),u(k,D),v(I,k,null),u(k,V),u(k,S),u(k,q),v(G,k,null),u(k,O),u(k,T),u(L,y),u(L,z),u(L,A),u(L,F),u(F,J),v(K,F,null),u(F,M),u(F,N),u(F,Q),v(U,F,null),u(F,W),v(X,F,null),u(F,Y),v(Z,F,null),u(F,_),v(nn,F,null),u(F,en),u(F,an),u(F,rn),v(tn,F,null),u(F,$n),u(F,sn),u(F,fn),v(ln,F,null),u(F,mn),u(L,on),u(L,gn),u(d,cn),u(d,un),v(pn,un,null),u(d,hn),u(d,wn),u(wn,bn),u(wn,vn),u(wn,Bn),v(Rn,Bn,null),u(Bn,En),u(Bn,xn),u(Bn,Cn),v(Hn,Bn,null),u(Bn,Ln),v(Pn,Bn,null),u(Bn,jn),v(kn,Bn,null),u(Bn,Dn),u(Bn,In),u(Bn,Vn),v(Sn,Bn,null),u(Bn,qn),v(Gn,Bn,null),u(Bn,On),u(Bn,Tn),u(Bn,yn),v(zn,Bn,null),u(Bn,An),u(wn,Fn),u(wn,Jn),u(wn,Kn),u(wn,Mn),u(Mn,Nn),v(Qn,Mn,null),u(Mn,Un),u(Mn,Wn),u(Mn,Xn),u(wn,Yn),u(wn,Zn),_n=!0},p(n,[e]){const a={};!dn&&2&e&&(dn=!0,a.codeExeProps=n[1],p((()=>dn=!1))),pn.$set(a)},i(n){_n||(B(I.$$.fragment,n),B(G.$$.fragment,n),B(K.$$.fragment,n),B(U.$$.fragment,n),B(X.$$.fragment,n),B(Z.$$.fragment,n),B(nn.$$.fragment,n),B(tn.$$.fragment,n),B(ln.$$.fragment,n),B(pn.$$.fragment,n),B(Rn.$$.fragment,n),B(Hn.$$.fragment,n),B(Pn.$$.fragment,n),B(kn.$$.fragment,n),B(Sn.$$.fragment,n),B(Gn.$$.fragment,n),B(zn.$$.fragment,n),B(Qn.$$.fragment,n),_n=!0)},o(n){R(I.$$.fragment,n),R(G.$$.fragment,n),R(K.$$.fragment,n),R(U.$$.fragment,n),R(X.$$.fragment,n),R(Z.$$.fragment,n),R(nn.$$.fragment,n),R(tn.$$.fragment,n),R(ln.$$.fragment,n),R(pn.$$.fragment,n),R(Rn.$$.fragment,n),R(Hn.$$.fragment,n),R(Pn.$$.fragment,n),R(kn.$$.fragment,n),R(Sn.$$.fragment,n),R(Gn.$$.fragment,n),R(zn.$$.fragment,n),R(Qn.$$.fragment,n),_n=!1},d(e){e&&o(d),E(I),E(G),E(K),E(U),E(X),E(Z),E(nn),E(tn),E(ln),n[3](null),E(pn),E(Rn),E(Hn),E(Pn),E(kn),E(Sn),E(Gn),E(zn),E(Qn)}}}function L(n,a,r){let t,$={code:'const num = 10;\nlet result;\nif (num % 2 === 0) {\n  result = num + " is Even.";\n} else {\n  result = num + " is Odd.";\n}\nreturn result;',resultString:"",logs:[]};return[t,$,{},function(n){e[n?"unshift":"push"]((()=>{t=n,r(0,t)}))},function(n){$=n,r(1,$)}]}class P extends d{constructor(e){super(),i(this,e,L,H,n,{})}}export{P as component};
