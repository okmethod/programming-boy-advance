import{s as n,p as e,e as a,a as t,t as r,c as s,b as $,m as l,f,d as o,g as i,h as m,i as g,j as c,q as p}from"../chunks/scheduler.BHmUeXpX.js";import{S as h,i as u,f as d,b as w,d as b,m as v,t as B,a as x,e as E}from"../chunks/index.DEa-WhvI.js";import{C as L}from"../chunks/CodeSpan.CLzOd-Y1.js";import{C as R}from"../chunks/CodeExecuter.B1Kf-BD8.js";function C(n){let h,u,C,j,k,H,P,D,I,S,T,V,q,M,G,y,z,A,F,J,K,N,O,Q,U,W,X,Y,Z,_,nn,en,an,tn,rn,sn,$n,ln,fn,on,mn,gn,cn,pn,hn,un,dn,wn,bn,vn,Bn,xn="繰り返し(ループ)",En='<hr class="cBorderLine"/> <p>初めに「同じ処理を繰り返す」と書きましたが、実際はこのプログラムのように変数を使って、\n      <br/>\n      少しだけ異なる処理を複数回実行したいときに使うこともできます。\n      <br/>\n      条件式やループ内の処理を書き換えて、繰り返しの回数や内容を変えてみましょう。思ったとおりに動きましたか？</p> <hr class="cBorderLine"/>';function Ln(e){n[3](e)}I=new L({props:{data:["for","red"]}}),q=new L({props:{data:[["for","red"],[" ( ... )","white"]]}}),N=new L({props:{data:[["let ","red"],["i = ","white"],["1","lightblue"],[";","white"]]}}),Q=new L({props:{data:["i","white"]}}),W=new L({props:{data:["1","blue"]}}),_=new L({props:{data:[["i <= ","white"],["10","lightblue"],[";","white"]]}}),en=new L({props:{data:["i","white"]}}),tn=new L({props:{data:["10","blue"]}}),ln=new L({props:{data:[["i++;","white"]]}}),on=new L({props:{data:["i","white"]}});let Rn={};return void 0!==n[1]&&(Rn.codeExeProps=n[1]),dn=new R({props:Rn}),n[2](dn),e.push((()=>d(dn,"codeExeProps",Ln))),{c(){h=a("div"),u=a("h2"),u.textContent=xn,C=t(),j=a("div"),k=a("hr"),H=t(),P=a("p"),D=r("最後に紹介する強力なアイテムは「繰り返し("),w(I.$$.fragment),S=r("ループ)」です。\n      "),T=a("br"),V=r("\n      繰り返しは、"),w(q.$$.fragment),M=r(" の括弧で囲まれた式に従い、同じ処理を繰り返し行うことができます。"),G=t(),y=a("hr"),z=t(),A=a("p"),F=r("このプログラムでは、1 から 10 までの数値を配列に格納しています。\n      "),J=a("br"),K=r("\n      括弧の中の初めの条件式 "),w(N.$$.fragment),O=r(" は、変数"),w(Q.$$.fragment),U=r(" が "),w(W.$$.fragment),X=r(" からスタートすることを示しています。\n      "),Y=a("br"),Z=r("\n      次の条件式 "),w(_.$$.fragment),nn=r(" は、変数"),w(en.$$.fragment),an=r(" が "),w(tn.$$.fragment),rn=r(" 以下である限り、繰り返し処理を続けることを示しています。\n      "),sn=a("br"),$n=r("\n      最後の条件式 "),w(ln.$$.fragment),fn=r(" は、ループ毎に変数"),w(on.$$.fragment),mn=r(" の値を 1\n      ずつ増やすことを示しています。\n      "),gn=a("br"),cn=r("\n      実行して、ループがどのように動くか見てみましょう。"),pn=t(),hn=a("hr"),un=t(),w(dn.$$.fragment),bn=t(),vn=a("div"),vn.innerHTML=En,this.h()},l(n){h=s(n,"DIV",{class:!0});var e=$(h);u=s(e,"H2",{class:!0,"data-svelte-h":!0}),"svelte-2988aw"!==l(u)&&(u.textContent=xn),C=f(e),j=s(e,"DIV",{class:!0});var a=$(j);k=s(a,"HR",{class:!0}),H=f(a),P=s(a,"P",{});var t=$(P);D=o(t,"最後に紹介する強力なアイテムは「繰り返し("),b(I.$$.fragment,t),S=o(t,"ループ)」です。\n      "),T=s(t,"BR",{}),V=o(t,"\n      繰り返しは、"),b(q.$$.fragment,t),M=o(t," の括弧で囲まれた式に従い、同じ処理を繰り返し行うことができます。"),t.forEach(i),G=f(a),y=s(a,"HR",{class:!0}),z=f(a),A=s(a,"P",{});var r=$(A);F=o(r,"このプログラムでは、1 から 10 までの数値を配列に格納しています。\n      "),J=s(r,"BR",{}),K=o(r,"\n      括弧の中の初めの条件式 "),b(N.$$.fragment,r),O=o(r," は、変数"),b(Q.$$.fragment,r),U=o(r," が "),b(W.$$.fragment,r),X=o(r," からスタートすることを示しています。\n      "),Y=s(r,"BR",{}),Z=o(r,"\n      次の条件式 "),b(_.$$.fragment,r),nn=o(r," は、変数"),b(en.$$.fragment,r),an=o(r," が "),b(tn.$$.fragment,r),rn=o(r," 以下である限り、繰り返し処理を続けることを示しています。\n      "),sn=s(r,"BR",{}),$n=o(r,"\n      最後の条件式 "),b(ln.$$.fragment,r),fn=o(r," は、ループ毎に変数"),b(on.$$.fragment,r),mn=o(r," の値を 1\n      ずつ増やすことを示しています。\n      "),gn=s(r,"BR",{}),cn=o(r,"\n      実行して、ループがどのように動くか見てみましょう。"),r.forEach(i),pn=f(a),hn=s(a,"HR",{class:!0}),a.forEach(i),un=f(e),b(dn.$$.fragment,e),bn=f(e),vn=s(e,"DIV",{class:!0,"data-svelte-h":!0}),"svelte-tjkq7e"!==l(vn)&&(vn.innerHTML=En),e.forEach(i),this.h()},h(){m(u,"class","cLessonTitle"),m(k,"class","cBorderLine"),m(y,"class","cBorderLine"),m(hn,"class","cBorderLine"),m(j,"class","w-full"),m(vn,"class","w-full"),m(h,"class","cBookContents")},m(n,e){g(n,h,e),c(h,u),c(h,C),c(h,j),c(j,k),c(j,H),c(j,P),c(P,D),v(I,P,null),c(P,S),c(P,T),c(P,V),v(q,P,null),c(P,M),c(j,G),c(j,y),c(j,z),c(j,A),c(A,F),c(A,J),c(A,K),v(N,A,null),c(A,O),v(Q,A,null),c(A,U),v(W,A,null),c(A,X),c(A,Y),c(A,Z),v(_,A,null),c(A,nn),v(en,A,null),c(A,an),v(tn,A,null),c(A,rn),c(A,sn),c(A,$n),v(ln,A,null),c(A,fn),v(on,A,null),c(A,mn),c(A,gn),c(A,cn),c(j,pn),c(j,hn),c(h,un),v(dn,h,null),c(h,bn),c(h,vn),Bn=!0},p(n,[e]){const a={};!wn&&2&e&&(wn=!0,a.codeExeProps=n[1],p((()=>wn=!1))),dn.$set(a)},i(n){Bn||(B(I.$$.fragment,n),B(q.$$.fragment,n),B(N.$$.fragment,n),B(Q.$$.fragment,n),B(W.$$.fragment,n),B(_.$$.fragment,n),B(en.$$.fragment,n),B(tn.$$.fragment,n),B(ln.$$.fragment,n),B(on.$$.fragment,n),B(dn.$$.fragment,n),Bn=!0)},o(n){x(I.$$.fragment,n),x(q.$$.fragment,n),x(N.$$.fragment,n),x(Q.$$.fragment,n),x(W.$$.fragment,n),x(_.$$.fragment,n),x(en.$$.fragment,n),x(tn.$$.fragment,n),x(ln.$$.fragment,n),x(on.$$.fragment,n),x(dn.$$.fragment,n),Bn=!1},d(e){e&&i(h),E(I),E(q),E(N),E(Q),E(W),E(_),E(en),E(tn),E(ln),E(on),n[2](null),E(dn)}}}function j(n,a,t){let r,s={allowedGlobals:{},code:'let list = [];\nfor (let i = 1; i <= 10; i++) {\n  log("loop: i = " + i);\n  list = [...list, i];\n}\n\nreturn list;',resultString:"",logs:[]};return[r,s,function(n){e[n?"unshift":"push"]((()=>{r=n,t(0,r)}))},function(n){s=n,t(1,s)}]}class k extends h{constructor(e){super(),u(this,e,j,C,n,{})}}export{k as component};
